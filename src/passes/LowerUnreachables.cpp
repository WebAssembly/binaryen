/*
 * Copyright 2020 WebAssembly Community Group participants
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Infers the proper WebAssembly types for unreachable control flow expressions
// and eliminates the redundant unreachable instructions generated by
// BinaryenIRWriter where possible. After unreachable lowering, the only
// expressions that still have Unreachable type are instructions that can never
// return.

#include "ir/stack-utils.h"
#include "pass.h"

namespace wasm {

namespace {

// Whether it is valid for `curr` to be unreachable after lowering.
bool mayBeUnreachable(Expression* curr) {
  switch (curr->_id) {
    case Expression::Id::BreakId:
      return curr->cast<Break>()->condition == nullptr;
    case Expression::Id::CallId:
      return curr->cast<Call>()->isReturn;
    case Expression::Id::CallIndirectId:
      return curr->cast<CallIndirect>()->isReturn;
    case Expression::Id::ReturnId:
    case Expression::Id::SwitchId:
    case Expression::Id::UnreachableId:
    case Expression::Id::ThrowId:
    case Expression::Id::RethrowId:
      return true;
    default:
      return false;
  }
}

struct LowerUnreachablesPass
  : public WalkerPass<PostWalker<LowerUnreachablesPass>> {
  using Super = WalkerPass<PostWalker<LowerUnreachablesPass>>;
  bool isFunctionParallel() override { return true; }
  Pass* create() override { return new LowerUnreachablesPass; }

  static void scan(LowerUnreachablesPass* self, Expression** currp) {
    // Visit only control flow children, since we know all other children will
    // be pops and we are not interested in those. Also pre-visit nodes instead
    // of post-visiting them because type inference depends on parents being
    // typed first.
    Expression* curr = *currp;
    switch (curr->_id) {
      case Expression::Id::BlockId: {
        // Visit children only through the first unreachable, since any further
        // children will be discarded before we could visit them.
        for (auto*& child : curr->cast<Block>()->list) {
          self->pushTask(scan, &child);
          if (child->type == Type::unreachable) {
            break;
          }
        }
        self->pushTask(doVisitBlock, currp);
        break;
      }
      case Expression::Id::IfId:
        self->maybePushTask(scan, &curr->cast<If>()->ifFalse);
        self->pushTask(scan, &curr->cast<If>()->ifTrue);
        self->pushTask(doVisitIf, currp);
        break;
      case Expression::Id::LoopId:
        self->pushTask(scan, &curr->cast<Loop>()->body);
        self->pushTask(doVisitLoop, currp);
        break;
      case Expression::Id::TryId:
        self->pushTask(scan, &curr->cast<Try>()->catchBody);
        self->pushTask(scan, &curr->cast<Try>()->body);
        self->pushTask(scan, &curr->cast<Try>()->body);
        self->pushTask(doVisitTry, currp);
        break;
      default:
        break;
    }
  }

  void visitBlock(Block* curr) {
    size_t numReachable = 0;
    for (; numReachable < curr->list.size(); ++numReachable) {
      if (curr->list[numReachable]->type == Type::unreachable) {
        break;
      }
    }
    if (numReachable == curr->list.size()) {
      return;
    }
    // Keep the first unreachable child and nothing after it
    curr->list.resize(numReachable + 1);
    auto* unreachable = curr->list[numReachable];
    // If it is control flow, figure out what type it should have
    if (Properties::isControlFlowStructure(unreachable)) {
      // If `unreachable` consumes any values (besides an i32 if it is an If) or
      // if it produces multiple values and multivalue is not enabled, then
      // append an `unreachable` to the list after all to make the typing work
      // out. Otherwise, update the type accordingly.  TODO: Implement control
      // flow input types for use here.
      StackFlow flow(curr);
      auto sig = flow.getSignature(unreachable);
      bool needsExtraUnreachable;
      if (unreachable->is<If>()) {
        needsExtraUnreachable = sig.params != Type::i32;
      } else {
        needsExtraUnreachable = sig.params != Type::none;
      }
      if (!getModule()->features.hasMultivalue() && sig.results.isMulti()) {
        needsExtraUnreachable = true;
      }
      if (needsExtraUnreachable) {
        curr->list.push_back(Builder(*getModule()).makeUnreachable());
        unreachable->type = Type::none;
      } else {
        unreachable->type = sig.results;
      }
    }
  }

  void visitIf(If* curr) {
    // The If type must be a supertype of the individual arm types, so just
    // reuse it for both arms. This can save space in the type section.
    curr->ifTrue->type = curr->type;
    if (curr->ifFalse) {
      curr->ifFalse->type = curr->type;
    }
  }

  void visitLoop(Loop* curr) { curr->body->type = curr->type; }

  void visitTry(Try* curr) {
    curr->body->type = curr->type;
    curr->catchBody->type = curr->type;
  }

  void doWalkFunction(Function* func) {
    if (func->profile != IRProfile::Stacky) {
      return;
    }

    func->body->type = func->sig.results;
    Super::doWalkFunction(func);

#ifndef NDEBUG
    // Assert that only instructions that never return have unreachable type
    struct AssertValidUnreachableTypes
      : PostWalker<AssertValidUnreachableTypes,
                   UnifiedExpressionVisitor<AssertValidUnreachableTypes>> {
      void visitExpression(Expression* curr) {
        if (curr->type == Type::unreachable) {
          assert(mayBeUnreachable(curr) &&
                 "Unexpected unreachable instruction");
        }
      }
    } asserter;
    asserter.walkFunction(func);
#endif // NDEBUG
  }
};

} // anonymous namespace

Pass* createLowerUnreachablesPass() { return new LowerUnreachablesPass; }

} // namespace wasm
