#!/usr/bin/env python3
# Copyright 2021 WebAssembly Community Group participants
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A test case update script.

This script is a utility to update wasm-opt based lit tests with new FileCheck
patterns. It is based on LLVM's update_llc_test_checks.py script.
"""

import argparse
import glob
import os
import re
import subprocess
import sys
import tempfile


script_name = os.path.basename(__file__)

RUN_LINE_RE = re.compile(r'^\s*;;\s*RUN:\s*(.*)$')
CHECK_PREFIX_RE = re.compile(r'.*--check-prefix[= ](\S+).*')

items = ['type', 'import', 'global', 'memory', 'data', 'table', 'elem', 'tag',
         'export', 'start', 'func']
ITEM_RE = re.compile(r'(^\s*)\((' + '|'.join(items) + r')\s+(\$?[^\s()]*).*$',
                     re.MULTILINE)


class OutputModule:
    def __init__(self, all_items):
        # Whether all items will be emitted or just the named items
        self.all_items = all_items
        # The index of the next item not yet emitted
        self.index = 0
        # Map (kind, name) to [lines]
        self.items = {}

    def _emit_item_checks(self, prefix, indent, lines, out):
        out.append(f'{indent};; {prefix}:     {lines[0]}')
        for line in lines[1:]:
            out.append(f'{indent};; {prefix}-NEXT:{line}')

    def emit_checks(self, prefix, indent, kind, name, out):
        if not name:
            return

        if self.all_items:
            # If the output for this prefix contains an item with this
            # name, emit all the items up to and including the matching
            # item.
            item_list = list(self.items.items())
            found = False
            for new_index in range(self.index, len(item_list)):
                if (kind, name) == item_list[new_index][0]:
                    found = True
                    break

            if not found:
                return

            new_index += 1
            for (out_kind, out_name), lines in item_list[self.index:new_index]:
                self._emit_item_checks(prefix, indent, lines, out)

            self.index = new_index
        else:
            lines = self.items.get((kind, name), None)
            if lines is not None:
                self._emit_item_checks(prefix, indent, lines, out)

    def emit_final_checks(self, prefix, out):
        if self.all_items:
            item_list = list(self.items.items())
            for _, lines in item_list[self.index:]:
                self._emit_item_checks(prefix, '', lines, out)


def warn(msg):
    print(f'WARNING: {msg}', file=sys.stderr)


def itertests(args):
    """
    Yield (filename, lines) for each test specified in the command line args
    """
    for pattern in args.tests:
        tests = glob.glob(pattern, recursive=True)
        if not tests:
            warn(f'No tests matched {pattern}. Ignoring it.')
            continue
        for test in tests:
            with open(test) as f:
                lines = [line.rstrip() for line in f]
            first_line = lines[0] if lines else ''
            if script_name not in first_line and not args.force:
                warn(f'Skipping test {test} which was not generated by '
                     f'{script_name}. Use -f to override.')
                continue
            yield test, lines


def find_run_lines(test, lines):
    line_matches = [RUN_LINE_RE.match(l) for l in lines]
    matches = [match.group(1) for match in line_matches if match]
    if not matches:
        warn(f'No RUN lines found in {test}. Ignoring.')
        return []
    run_lines = [matches[0]]
    for line in matches[1:]:
        if run_lines[-1].endswith('\\'):
            run_lines[-1] = run_lines[-1].rstrip('\\') + ' ' + line
        else:
            run_lines.append(line)
    return run_lines


def run_command(args, test, tmp, command):
    env = dict(os.environ)
    env['PATH'] = args.binaryen_bin + os.pathsep + env['PATH']
    command = command.replace('%s', test)
    command = command.replace('%t', tmp)
    return subprocess.check_output(command, shell=True, env=env).decode('utf-8')


def find_end(module, start):
    # Find the index one past the closing parenthesis corresponding to the first
    # open parenthesis at `start`.
    assert module[start] == '('
    depth = 1
    for end in range(start + 1, len(module)):
        if depth == 0:
            break
        elif module[end] == '(':
            depth += 1
        elif module[end] == ')':
            depth -= 1
    return end


def split_output(module, all_items):
    out = OutputModule(all_items)
    for match in ITEM_RE.finditer(module):
        kind = match.group(2)
        name = match.group(3)
        end = find_end(module, match.end(1))
        lines = module[match.start():end].split('\n')
        out.items[(kind, name)] = lines
    return out


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--binaryen-bin', dest='binaryen_bin', default='bin',
        help=('Specifies the path to the Binaryen executables in the CMake build'
              ' directory. Default: bin/ of current directory (i.e. assume an'
              ' in-tree build).'))
    parser.add_argument(
        '-f', '--force', action='store_true',
        help=('Generate FileCheck patterns even for test files whose existing '
              'patterns were not generated by this script.'))
    parser.add_argument(
        '--dry-run', action='store_true',
        help=('Print the updated test file contents instead of changing the '
              'test files'))
    parser.add_argument(
        '--all-items', action='store_true',
        help=('Generate FileCheck patterns for all output module items, not '
              'just those named in the input'))
    parser.add_argument('tests', nargs='+', help='The test files to update')
    args = parser.parse_args()
    args.binaryen_bin = os.path.abspath(args.binaryen_bin)

    tmp = tempfile.mktemp()

    for test, lines in itertests(args):
        # List of (prefix, command)
        run_list = []
        for line in find_run_lines(test, lines):
            commands = [cmd.strip() for cmd in line.rsplit('|', 1)]
            filecheck_cmd = ''
            if len(commands) > 1 and commands[1].startswith('filecheck '):
                filecheck_cmd = commands[1]
                commands = commands[:1]

            check_prefix = ''
            if filecheck_cmd.startswith('filecheck '):
                prefix_match = CHECK_PREFIX_RE.match(filecheck_cmd)
                if prefix_match:
                    check_prefix = prefix_match.group(1)
                else:
                    check_prefix = 'CHECK'

            run_list.append((check_prefix, commands[0]))

        all_items = (args.all_items or
                     (lines and script_name in lines[0] and
                      '--all-items' in lines[0]))

        # Map check prefixes to OutputModules
        output_modules = {}
        for prefix, command, in run_list:
            output = run_command(args, test, tmp, command)
            if prefix:
                output_modules[prefix] = split_output(output, all_items)

        script = script_name
        if all_items:
            script += ' --all-items'
        notice = (f';; NOTE: Assertions have been generated by {script} and ' +
                  'should not be edited.')
        output_lines = [notice]

        any_prefix = '|'.join(output_modules.keys())
        check_line_re = re.compile(r'^\s*;;\s*(' + any_prefix +
                                   r')(?:-NEXT|-LABEL|-NOT)?: .*$')

        # Skip the notice if it is already in the output
        if lines and script_name in lines[0]:
            lines = lines[1:]

        for line in lines:
            # Skip pre-existing check lines; we will regenerate them.
            if check_line_re.match(line):
                continue
            match = ITEM_RE.match(line)
            if match:
                indent, kind, name = match.groups()
                for prefix, output in output_modules.items():
                    output.emit_checks(prefix, indent, kind, name, output_lines)
            output_lines.append(line)

        # Output any remaining checks for each prefix
        for prefix, output in output_modules.items():
            output.emit_final_checks(prefix, output_lines)

        if args.dry_run:
            print('\n'.join(output_lines))
        else:
            with open(test, 'w') as f:
                for line in output_lines:
                    f.write(line + '\n')


if __name__ == '__main__':
    main()
