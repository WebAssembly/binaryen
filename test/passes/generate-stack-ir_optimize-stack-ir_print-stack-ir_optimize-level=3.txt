$big_negative:
0 (f64.const -2147483648)
1 set_local $temp
2 (f64.const -2147483648)
3 set_local $temp
4 (f64.const -21474836480)
5 set_local $temp
6 (f64.const 0.039625)
7 set_local $temp
8 (f64.const -0.039625)
9 set_local $temp

$importedDoubles:
0 block
1 (i32.const 8)
2 f64.load
3 (i32.const 16)
4 f64.load
5 f64.add
6 (i32.const 16)
7 f64.load
8 f64.neg
9 f64.add
10 (i32.const 8)
11 f64.load
12 f64.neg
13 f64.add
14 set_local $temp
15 (i32.const 24)
16 i32.load
17 (i32.const 0)
18 i32.gt_s
19 if
20 (f64.const -3.4)
21 br $topmost
22 end (none)
23 (i32.const 32)
24 f64.load
25 (f64.const 0)
26 f64.gt
27 if
28 (f64.const 5.6)
29 br $topmost
30 end (none)
31 (f64.const 1.2)
32 end (f64)

$doubleCompares:
0 block
1 get_local $x
2 (f64.const 0)
3 f64.gt
4 if
5 (f64.const 1.2)
6 br $topmost
7 end (none)
8 get_local $Int
9 (f64.const 0)
10 f64.gt
11 if
12 (f64.const -3.4)
13 br $topmost
14 end (none)
15 get_local $Double
16 (i32.const 0)
17 i32.gt_s
18 if
19 (f64.const 5.6)
20 br $topmost
21 end (none)
22 get_local $x
23 get_local $y
24 f64.lt
25 if
26 get_local $x
27 br $topmost
28 end (none)
29 get_local $y
30 end (f64)

$intOps:
0 get_local $x
1 (i32.const 0)
2 i32.eq

$hexLiterals:
0 (i32.const 0)
1 (i32.const 313249263)
2 i32.add
3 (i32.const -19088752)
4 i32.add
5 drop

$conversions:
0 get_local $d
1 call $f64-to-int
2 set_local $i
3 get_local $i
4 f64.convert_s/i32
5 set_local $d
6 get_local $i
7 (i32.const 0)
8 i32.shr_u
9 f64.convert_u/i32
10 set_local $d

$seq:
0 (f64.const 0.1)
1 drop
2 (f64.const 5.1)
3 (f64.const 3.2)
4 drop
5 (f64.const 4.2)
6 f64.sub
7 set_local $J

$switcher:
0 block
1 block
2 block
3 block
4 get_local $x
5 (i32.const 1)
6 i32.sub
7 br_table $switch-case$1 $switch-case$2 $switch-default$3
8 end (none)
9 (i32.const 1)
10 br $topmost
11 end (none)
12 (i32.const 2)
13 br $topmost
14 end (none)
15 nop
16 block
17 block
18 block
19 get_local $x
20 (i32.const 5)
21 i32.sub
22 br_table $switch-case$6 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-case$5 $switch-default$7
23 end (none)
24 (i32.const 121)
25 br $topmost
26 end (none)
27 (i32.const 51)
28 br $topmost
29 end (none)
30 nop
31 block
32 block
33 block
34 block
35 block
36 block
37 get_local $x
38 (i32.const 2)
39 i32.sub
40 br_table $switch-case$15 $switch-default$16 $switch-default$16 $switch-case$12 $switch-default$16 $switch-default$16 $switch-default$16 $switch-default$16 $switch-case$9 $switch-default$16 $switch-case$8 $switch-default$16
41 end (none)
42 br $label$break$Lout
43 end (none)
44 br $label$break$Lout
45 end (none)
46 block
47 loop
48 br $while-out$10
49 end (none)
50 unreachable
51 end (none)
52 end (none)
53 loop
54 br $label$break$Lout
55 end (none)
56 unreachable
57 end (none)
58 nop
59 end (none)
60 (i32.const 0)
61 end (i32)

$blocker:
0 block
1 br $label$break$L
2 end (none)

$frem:
0 (f64.const 5.5)
1 (f64.const 1.2)
2 call $f64-rem

$big_uint_div_u:
0 (i32.const -1)
1 (i32.const 2)
2 i32.div_u
3 (i32.const -1)
4 i32.and

$fr:
0 get_local $z
1 f32.demote/f64
2 drop
3 get_local $y
4 drop
5 (f32.const 5)
6 drop
7 (f32.const 0)
8 drop
9 (f32.const 5)
10 drop
11 (f32.const 0)
12 drop

$negZero:
0 (f64.const -0)

$abs:
0 (i32.const 0)
1 set_local $asm2wasm_i32_temp
2 (i32.const 0)
3 get_local $asm2wasm_i32_temp
4 i32.sub
5 get_local $asm2wasm_i32_temp
6 get_local $asm2wasm_i32_temp
7 (i32.const 0)
8 i32.lt_s
9 select
10 set_local $x
11 (f64.const 0)
12 f64.abs
13 set_local $y
14 (f32.const 0)
15 f32.abs
16 set_local $z

$neg:
0 get_local $x
1 f32.neg
2 (i32.const 1)
3 (i32.const 7)
4 i32.and
5 (i32.const 8)
6 i32.add
7 call_indirect (type $FUNCSIG$vf)

$cneg:
0 get_local $x
1 (i32.const 1)
2 (i32.const 7)
3 i32.and
4 (i32.const 8)
5 i32.add
6 call_indirect (type $FUNCSIG$vf)

$___syscall_ret:
0 get_local $$0
1 (i32.const 0)
2 i32.shr_u
3 (i32.const -4096)
4 i32.gt_u
5 drop

$z:
0 nop

$w:
0 nop

$block_and_after:
0 block
1 (i32.const 1)
2 drop
3 br $waka
4 end (none)
5 (i32.const 0)

$loop-roundtrip:
0 loop
1 get_local $0
2 drop
3 get_local $0
4 end (f64)

$big-i64:
0 (i64.const -9218868437227405313)

$i64-store32:
0 get_local $0
1 get_local $1
2 i64.store32

$return-unreachable:
0 (i32.const 1)
1 return

$unreachable-block:
0 (i32.const 1)
1 drop
2 (i32.const 2)
3 return

$unreachable-block-toplevel:
0 (i32.const 1)
1 drop
2 (i32.const 2)
3 return

$unreachable-block0:
0 (i32.const 2)
1 return

$unreachable-block0-toplevel:
0 (i32.const 2)
1 return

$unreachable-block-with-br:
0 block
1 (i32.const 1)
2 drop
3 br $block
4 end (none)
5 (i32.const 1)

$unreachable-if:
0 (i32.const 3)
1 if
2 (i32.const 2)
3 return
4 else
5 (i32.const 1)
6 return
7 end (none)
8 unreachable

$unreachable-if-toplevel:
0 (i32.const 3)
1 if
2 (i32.const 2)
3 return
4 else
5 (i32.const 1)
6 return
7 end (none)
8 unreachable

$unreachable-loop:
0 loop
1 nop
2 (i32.const 1)
3 return
4 end (none)
5 unreachable

$unreachable-loop0:
0 loop
1 (i32.const 1)
2 return
3 end (none)
4 unreachable

$unreachable-loop-toplevel:
0 loop
1 nop
2 (i32.const 1)
3 return
4 end (none)
5 unreachable

$unreachable-loop0-toplevel:
0 loop
1 (i32.const 1)
2 return
3 end (none)
4 unreachable

$unreachable-ifs:
0 unreachable

$unreachable-if-arm:
0 (i32.const 1)
1 if
2 nop
3 else
4 unreachable
5 end (none)

$local-to-stack:
0 (i32.const 1)
1 call $local-to-stack
2 (i32.const 2)
3 call $local-to-stack
4 drop

$local-to-stack-1:
0 (i32.const 1)
1 call $local-to-stack
2 (i32.const 2)
3 call $local-to-stack
4 drop
5 i32.eqz

$local-to-stack-1b:
0 (i32.const 1)
1 call $local-to-stack
2 (i32.const 2)
3 call $local-to-stack
4 drop
5 (i32.const 3)
6 i32.add

$local-to-stack-1c-no:
0 (i32.const 1)
1 call $local-to-stack
2 set_local $temp
3 (i32.const 2)
4 call $local-to-stack
5 drop
6 (i32.const 3)
7 get_local $temp
8 i32.add

$local-to-stack-2-no:
0 (i32.const 1)
1 call $local-to-stack
2 set_local $temp
3 (i32.const 2)
4 call $local-to-stack
5 drop
6 get_local $temp
7 get_local $temp
8 i32.add

$local-to-stack-3-no:
0 (i32.const 1)
1 if
2 (i32.const 1)
3 call $local-to-stack
4 set_local $temp
5 else
6 (i32.const 2)
7 call $local-to-stack
8 set_local $temp
9 end (none)
10 (i32.const 3)
11 call $local-to-stack
12 drop
13 get_local $temp

$local-to-stack-multi-4:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 (i32.const 2)
3 call $local-to-stack-multi-4
4 drop
5 drop
6 (i32.const 3)
7 call $local-to-stack-multi-4
8 (i32.const 4)
9 call $local-to-stack-multi-4
10 drop

$local-to-stack-multi-5:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 (i32.const 2)
3 call $local-to-stack-multi-4
4 drop
5 drop
6 (i32.const 3)
7 call $local-to-stack-multi-4
8 (i32.const 4)
9 call $local-to-stack-multi-4
10 drop

$local-to-stack-multi-6-justone:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 (i32.const 2)
3 call $local-to-stack-multi-4
4 drop
5 drop
6 (i32.const 3)
7 call $local-to-stack-multi-4
8 set_local $temp2
9 (i32.const 4)
10 call $local-to-stack-multi-4
11 drop
12 get_local $temp2
13 get_local $temp2
14 i32.add

$local-to-stack-multi-7-justone:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 set_local $temp1
3 (i32.const 2)
4 call $local-to-stack-multi-4
5 drop
6 get_local $temp1
7 get_local $temp1
8 i32.add
9 drop
10 (i32.const 3)
11 call $local-to-stack-multi-4
12 (i32.const 4)
13 call $local-to-stack-multi-4
14 drop

$local-to-stack-overlapping-multi-8-no:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 set_local $temp1
3 (i32.const 1)
4 call $local-to-stack-multi-4
5 (i32.const 3)
6 call $local-to-stack-multi-4
7 drop
8 get_local $temp1
9 i32.add

$local-to-stack-overlapping-multi-9-yes:
0 (i32.const 1)
1 call $local-to-stack-multi-4
2 (i32.const 1)
3 call $local-to-stack-multi-4
4 (i32.const 3)
5 call $local-to-stack-multi-4
6 drop
7 i32.add

$local-to-stack-through-control-flow:
0 (i32.const 0)
1 call $local-to-stack-multi-4
2 (i32.const 1)
3 call $local-to-stack-multi-4
4 (i32.const 0)
5 if
6 nop
7 end (none)
8 drop
9 (i32.const 2)
10 call $local-to-stack-multi-4
11 block
12 br $block
13 end (none)
14 drop
15 drop

$local-to-stack-in-control-flow:
0 (i32.const 0)
1 if
2 (i32.const 0)
3 call $local-to-stack-multi-4
4 drop
5 else
6 (i32.const 1)
7 call $local-to-stack-multi-4
8 drop
9 end (none)

$remove-block:
0 (i32.const 0)
1 call $remove-block
2 (i32.const 1)
3 call $remove-block
4 (i32.const 2)
5 call $remove-block
6 drop
7 i32.eqz
8 i32.add

(module
 (type $FUNCSIG$vf (func (param f32)))
 (type $FUNCSIG$v (func))
 (type $FUNCSIG$id (func (param f64) (result i32)))
 (type $FUNCSIG$ddd (func (param f64 f64) (result f64)))
 (type $4 (func (result f64)))
 (type $5 (func (result i32)))
 (type $6 (func (param i32) (result i32)))
 (type $7 (func (param f64) (result f64)))
 (type $8 (func (result i64)))
 (type $9 (func (param i32 i64)))
 (import "env" "_emscripten_asm_const_vi" (func $_emscripten_asm_const_vi))
 (import "asm2wasm" "f64-to-int" (func $f64-to-int (param f64) (result i32)))
 (import "asm2wasm" "f64-rem" (func $f64-rem (param f64 f64) (result f64)))
 (table 10 anyfunc)
 (elem (i32.const 0) $z $big_negative $z $z $w $w $importedDoubles $w $z $cneg)
 (memory $0 4096 4096)
 (data (i32.const 1026) "\14\00")
 (export "big_negative" (func $big_negative))
 (func $big_negative (; 3 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $temp f64)
  (block $block0
   (set_local $temp
    (f64.const -2147483648)
   )
   (set_local $temp
    (f64.const -2147483648)
   )
   (set_local $temp
    (f64.const -21474836480)
   )
   (set_local $temp
    (f64.const 0.039625)
   )
   (set_local $temp
    (f64.const -0.039625)
   )
  )
 )
 (func $importedDoubles (; 4 ;) (; has Stack IR ;) (type $4) (result f64)
  (local $temp f64)
  (block $topmost (result f64)
   (set_local $temp
    (f64.add
     (f64.add
      (f64.add
       (f64.load
        (i32.const 8)
       )
       (f64.load
        (i32.const 16)
       )
      )
      (f64.neg
       (f64.load
        (i32.const 16)
       )
      )
     )
     (f64.neg
      (f64.load
       (i32.const 8)
      )
     )
    )
   )
   (if
    (i32.gt_s
     (i32.load
      (i32.const 24)
     )
     (i32.const 0)
    )
    (br $topmost
     (f64.const -3.4)
    )
   )
   (if
    (f64.gt
     (f64.load
      (i32.const 32)
     )
     (f64.const 0)
    )
    (br $topmost
     (f64.const 5.6)
    )
   )
   (f64.const 1.2)
  )
 )
 (func $doubleCompares (; 5 ;) (; has Stack IR ;) (type $FUNCSIG$ddd) (param $x f64) (param $y f64) (result f64)
  (local $t f64)
  (local $Int f64)
  (local $Double i32)
  (block $topmost (result f64)
   (if
    (f64.gt
     (get_local $x)
     (f64.const 0)
    )
    (br $topmost
     (f64.const 1.2)
    )
   )
   (if
    (f64.gt
     (get_local $Int)
     (f64.const 0)
    )
    (br $topmost
     (f64.const -3.4)
    )
   )
   (if
    (i32.gt_s
     (get_local $Double)
     (i32.const 0)
    )
    (br $topmost
     (f64.const 5.6)
    )
   )
   (if
    (f64.lt
     (get_local $x)
     (get_local $y)
    )
    (br $topmost
     (get_local $x)
    )
   )
   (get_local $y)
  )
 )
 (func $intOps (; 6 ;) (; has Stack IR ;) (type $5) (result i32)
  (local $x i32)
  (i32.eq
   (get_local $x)
   (i32.const 0)
  )
 )
 (func $hexLiterals (; 7 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (drop
   (i32.add
    (i32.add
     (i32.const 0)
     (i32.const 313249263)
    )
    (i32.const -19088752)
   )
  )
 )
 (func $conversions (; 8 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $i i32)
  (local $d f64)
  (block $block0
   (set_local $i
    (call $f64-to-int
     (get_local $d)
    )
   )
   (set_local $d
    (f64.convert_s/i32
     (get_local $i)
    )
   )
   (set_local $d
    (f64.convert_u/i32
     (i32.shr_u
      (get_local $i)
      (i32.const 0)
     )
    )
   )
  )
 )
 (func $seq (; 9 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $J f64)
  (set_local $J
   (f64.sub
    (block $block0 (result f64)
     (drop
      (f64.const 0.1)
     )
     (f64.const 5.1)
    )
    (block $block1 (result f64)
     (drop
      (f64.const 3.2)
     )
     (f64.const 4.2)
    )
   )
  )
 )
 (func $switcher (; 10 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (block $topmost (result i32)
   (block $switch$0
    (block $switch-default$3
     (block $switch-case$2
      (block $switch-case$1
       (br_table $switch-case$1 $switch-case$2 $switch-default$3
        (i32.sub
         (get_local $x)
         (i32.const 1)
        )
       )
      )
      (br $topmost
       (i32.const 1)
      )
     )
     (br $topmost
      (i32.const 2)
     )
    )
    (nop)
   )
   (block $switch$4
    (block $switch-default$7
     (block $switch-case$6
      (block $switch-case$5
       (br_table $switch-case$6 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-default$7 $switch-case$5 $switch-default$7
        (i32.sub
         (get_local $x)
         (i32.const 5)
        )
       )
      )
      (br $topmost
       (i32.const 121)
      )
     )
     (br $topmost
      (i32.const 51)
     )
    )
    (nop)
   )
   (block $label$break$Lout
    (block $switch-default$16
     (block $switch-case$15
      (block $switch-case$12
       (block $switch-case$9
        (block $switch-case$8
         (br_table $switch-case$15 $switch-default$16 $switch-default$16 $switch-case$12 $switch-default$16 $switch-default$16 $switch-default$16 $switch-default$16 $switch-case$9 $switch-default$16 $switch-case$8 $switch-default$16
          (i32.sub
           (get_local $x)
           (i32.const 2)
          )
         )
        )
        (br $label$break$Lout)
       )
       (br $label$break$Lout)
      )
      (block $while-out$10
       (loop $while-in$11
        (block $block1
         (br $while-out$10)
         (br $while-in$11)
        )
       )
       (br $label$break$Lout)
      )
     )
     (block $while-out$13
      (loop $while-in$14
       (block $block3
        (br $label$break$Lout)
        (br $while-in$14)
       )
      )
      (br $label$break$Lout)
     )
    )
    (nop)
   )
   (i32.const 0)
  )
 )
 (func $blocker (; 11 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (block $label$break$L
   (br $label$break$L)
  )
 )
 (func $frem (; 12 ;) (; has Stack IR ;) (type $4) (result f64)
  (call $f64-rem
   (f64.const 5.5)
   (f64.const 1.2)
  )
 )
 (func $big_uint_div_u (; 13 ;) (; has Stack IR ;) (type $5) (result i32)
  (local $x i32)
  (block $topmost (result i32)
   (set_local $x
    (i32.and
     (i32.div_u
      (i32.const -1)
      (i32.const 2)
     )
     (i32.const -1)
    )
   )
   (get_local $x)
  )
 )
 (func $fr (; 14 ;) (; has Stack IR ;) (type $FUNCSIG$vf) (param $x f32)
  (local $y f32)
  (local $z f64)
  (block $block0
   (drop
    (f32.demote/f64
     (get_local $z)
    )
   )
   (drop
    (get_local $y)
   )
   (drop
    (f32.const 5)
   )
   (drop
    (f32.const 0)
   )
   (drop
    (f32.const 5)
   )
   (drop
    (f32.const 0)
   )
  )
 )
 (func $negZero (; 15 ;) (; has Stack IR ;) (type $4) (result f64)
  (f64.const -0)
 )
 (func $abs (; 16 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $x i32)
  (local $y f64)
  (local $z f32)
  (local $asm2wasm_i32_temp i32)
  (block $block0
   (set_local $x
    (block $block1 (result i32)
     (set_local $asm2wasm_i32_temp
      (i32.const 0)
     )
     (select
      (i32.sub
       (i32.const 0)
       (get_local $asm2wasm_i32_temp)
      )
      (get_local $asm2wasm_i32_temp)
      (i32.lt_s
       (get_local $asm2wasm_i32_temp)
       (i32.const 0)
      )
     )
    )
   )
   (set_local $y
    (f64.abs
     (f64.const 0)
    )
   )
   (set_local $z
    (f32.abs
     (f32.const 0)
    )
   )
  )
 )
 (func $neg (; 17 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $x f32)
  (block $block0
   (set_local $x
    (f32.neg
     (get_local $x)
    )
   )
   (call_indirect (type $FUNCSIG$vf)
    (get_local $x)
    (i32.add
     (i32.and
      (i32.const 1)
      (i32.const 7)
     )
     (i32.const 8)
    )
   )
  )
 )
 (func $cneg (; 18 ;) (; has Stack IR ;) (type $FUNCSIG$vf) (param $x f32)
  (call_indirect (type $FUNCSIG$vf)
   (get_local $x)
   (i32.add
    (i32.and
     (i32.const 1)
     (i32.const 7)
    )
    (i32.const 8)
   )
  )
 )
 (func $___syscall_ret (; 19 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $$0 i32)
  (drop
   (i32.gt_u
    (i32.shr_u
     (get_local $$0)
     (i32.const 0)
    )
    (i32.const -4096)
   )
  )
 )
 (func $z (; 20 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (nop)
 )
 (func $w (; 21 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (nop)
 )
 (func $block_and_after (; 22 ;) (; has Stack IR ;) (type $5) (result i32)
  (block $waka
   (drop
    (i32.const 1)
   )
   (br $waka)
  )
  (i32.const 0)
 )
 (func $loop-roundtrip (; 23 ;) (; has Stack IR ;) (type $7) (param $0 f64) (result f64)
  (loop $loop-in1 (result f64)
   (drop
    (get_local $0)
   )
   (get_local $0)
  )
 )
 (func $big-i64 (; 24 ;) (; has Stack IR ;) (type $8) (result i64)
  (i64.const -9218868437227405313)
 )
 (func $i64-store32 (; 25 ;) (; has Stack IR ;) (type $9) (param $0 i32) (param $1 i64)
  (i64.store32
   (get_local $0)
   (get_local $1)
  )
 )
 (func $return-unreachable (; 26 ;) (; has Stack IR ;) (type $5) (result i32)
  (return
   (i32.const 1)
  )
 )
 (func $unreachable-block (; 27 ;) (; has Stack IR ;) (type $5) (result i32)
  (f64.abs
   (block $block
    (drop
     (i32.const 1)
    )
    (return
     (i32.const 2)
    )
   )
  )
 )
 (func $unreachable-block-toplevel (; 28 ;) (; has Stack IR ;) (type $5) (result i32)
  (block $block
   (drop
    (i32.const 1)
   )
   (return
    (i32.const 2)
   )
  )
 )
 (func $unreachable-block0 (; 29 ;) (; has Stack IR ;) (type $5) (result i32)
  (f64.abs
   (block $block
    (return
     (i32.const 2)
    )
   )
  )
 )
 (func $unreachable-block0-toplevel (; 30 ;) (; has Stack IR ;) (type $5) (result i32)
  (block $block
   (return
    (i32.const 2)
   )
  )
 )
 (func $unreachable-block-with-br (; 31 ;) (; has Stack IR ;) (type $5) (result i32)
  (block $block
   (drop
    (i32.const 1)
   )
   (br $block)
  )
  (i32.const 1)
 )
 (func $unreachable-if (; 32 ;) (; has Stack IR ;) (type $5) (result i32)
  (f64.abs
   (if
    (i32.const 3)
    (return
     (i32.const 2)
    )
    (return
     (i32.const 1)
    )
   )
  )
 )
 (func $unreachable-if-toplevel (; 33 ;) (; has Stack IR ;) (type $5) (result i32)
  (if
   (i32.const 3)
   (return
    (i32.const 2)
   )
   (return
    (i32.const 1)
   )
  )
 )
 (func $unreachable-loop (; 34 ;) (; has Stack IR ;) (type $5) (result i32)
  (f64.abs
   (loop $loop-in
    (nop)
    (return
     (i32.const 1)
    )
   )
  )
 )
 (func $unreachable-loop0 (; 35 ;) (; has Stack IR ;) (type $5) (result i32)
  (f64.abs
   (loop $loop-in
    (return
     (i32.const 1)
    )
   )
  )
 )
 (func $unreachable-loop-toplevel (; 36 ;) (; has Stack IR ;) (type $5) (result i32)
  (loop $loop-in
   (nop)
   (return
    (i32.const 1)
   )
  )
 )
 (func $unreachable-loop0-toplevel (; 37 ;) (; has Stack IR ;) (type $5) (result i32)
  (loop $loop-in
   (return
    (i32.const 1)
   )
  )
 )
 (func $unreachable-ifs (; 38 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (if
   (unreachable)
   (nop)
  )
  (if
   (unreachable)
   (unreachable)
  )
  (if
   (unreachable)
   (nop)
   (nop)
  )
  (if
   (unreachable)
   (unreachable)
   (nop)
  )
  (if
   (unreachable)
   (nop)
   (unreachable)
  )
  (if
   (unreachable)
   (unreachable)
   (unreachable)
  )
  (if
   (i32.const 1)
   (unreachable)
   (nop)
  )
  (if
   (i32.const 1)
   (nop)
   (unreachable)
  )
  (if
   (i32.const 1)
   (unreachable)
   (unreachable)
  )
 )
 (func $unreachable-if-arm (; 39 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (if
   (i32.const 1)
   (block $block
    (nop)
   )
   (block $block12
    (unreachable)
    (drop
     (i32.const 1)
    )
   )
  )
 )
 (func $local-to-stack (; 40 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (set_local $temp
   (call $local-to-stack
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 2)
   )
  )
  (get_local $temp)
 )
 (func $local-to-stack-1 (; 41 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (set_local $temp
   (call $local-to-stack
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 2)
   )
  )
  (i32.eqz
   (get_local $temp)
  )
 )
 (func $local-to-stack-1b (; 42 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (set_local $temp
   (call $local-to-stack
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 2)
   )
  )
  (i32.add
   (get_local $temp)
   (i32.const 3)
  )
 )
 (func $local-to-stack-1c-no (; 43 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (set_local $temp
   (call $local-to-stack
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 2)
   )
  )
  (i32.add
   (i32.const 3)
   (get_local $temp)
  )
 )
 (func $local-to-stack-2-no (; 44 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (set_local $temp
   (call $local-to-stack
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 2)
   )
  )
  (i32.add
   (get_local $temp)
   (get_local $temp)
  )
 )
 (func $local-to-stack-3-no (; 45 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (if
   (i32.const 1)
   (set_local $temp
    (call $local-to-stack
     (i32.const 1)
    )
   )
   (set_local $temp
    (call $local-to-stack
     (i32.const 2)
    )
   )
  )
  (drop
   (call $local-to-stack
    (i32.const 3)
   )
  )
  (get_local $temp)
 )
 (func $local-to-stack-multi-4 (; 46 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 2)
   )
  )
  (drop
   (get_local $temp1)
  )
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 4)
   )
  )
  (get_local $temp1)
 )
 (func $local-to-stack-multi-5 (; 47 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 2)
   )
  )
  (drop
   (get_local $temp1)
  )
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 4)
   )
  )
  (get_local $temp2)
 )
 (func $local-to-stack-multi-6-justone (; 48 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 2)
   )
  )
  (drop
   (get_local $temp1)
  )
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 4)
   )
  )
  (i32.add
   (get_local $temp2)
   (get_local $temp2)
  )
 )
 (func $local-to-stack-multi-7-justone (; 49 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 2)
   )
  )
  (drop
   (i32.add
    (get_local $temp1)
    (get_local $temp1)
   )
  )
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 4)
   )
  )
  (get_local $temp2)
 )
 (func $local-to-stack-overlapping-multi-8-no (; 50 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (i32.add
   (get_local $temp2)
   (get_local $temp1)
  )
 )
 (func $local-to-stack-overlapping-multi-9-yes (; 51 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (drop
   (call $local-to-stack-multi-4
    (i32.const 3)
   )
  )
  (i32.add
   (get_local $temp1)
   (get_local $temp2)
  )
 )
 (func $local-to-stack-through-control-flow (; 52 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $temp1 i32)
  (local $temp2 i32)
  (set_local $temp2
   (call $local-to-stack-multi-4
    (i32.const 0)
   )
  )
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 1)
   )
  )
  (if
   (i32.const 0)
   (nop)
  )
  (drop
   (get_local $temp1)
  )
  (set_local $temp1
   (call $local-to-stack-multi-4
    (i32.const 2)
   )
  )
  (block $block
   (br $block)
  )
  (drop
   (get_local $temp1)
  )
  (drop
   (get_local $temp2)
  )
 )
 (func $local-to-stack-in-control-flow (; 53 ;) (; has Stack IR ;) (type $FUNCSIG$v)
  (local $temp1 i32)
  (if
   (i32.const 0)
   (block $block
    (set_local $temp1
     (call $local-to-stack-multi-4
      (i32.const 0)
     )
    )
    (drop
     (get_local $temp1)
    )
   )
   (block $block13
    (set_local $temp1
     (call $local-to-stack-multi-4
      (i32.const 1)
     )
    )
    (drop
     (get_local $temp1)
    )
   )
  )
 )
 (func $remove-block (; 54 ;) (; has Stack IR ;) (type $6) (param $x i32) (result i32)
  (local $temp i32)
  (i32.add
   (call $remove-block
    (i32.const 0)
   )
   (i32.eqz
    (block $block (result i32)
     (set_local $temp
      (call $remove-block
       (i32.const 1)
      )
     )
     (drop
      (call $remove-block
       (i32.const 2)
      )
     )
     (get_local $temp)
    )
   )
  )
 )
)
