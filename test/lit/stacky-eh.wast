;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --optimize-level=3 --generate-stack-ir --optimize-stack-ir --roundtrip -S -o - | filecheck %s

(module
  (tag $e-i32 (param i32))

  ;; When converted to stack IR, the 'catch' block becomes:
  ;; catch $e-i32
  ;;   pop i32
  ;;   local.set $0
  ;;   i32.const 3
  ;;   local.set $1
  ;;   local.get $0
  ;;   local.get $2
  ;;
  ;; after running --optimize-level=3 --optimize-stack-ir, this becomes:
  ;; (--optimize-level=3 is necessary to run StackIROptimizer::local2Stack())
  ;; catch $e-i32
  ;;   pop i32
  ;;   i32.const 3
  ;;   local.set $1
  ;;   local.set $2
  ;;
  ;; which becomes 'stacky' in Binaryen parlance. If we run --roundtrip on this,
  ;; this will be written to binary and read back. In the binary reader,
  ;; Binaryen has a special routine of creating a block and a
  ;; local.get/local.set to read stacky code in to Binaryen AST. So if we don't
  ;; do any post-fixup, this becomes:
  ;; (catch $e-i32
  ;;   (local.set $2
  ;;     (block (result i32)
  ;;       (local.set $3
  ;;         (pop i32)
  ;;       )
  ;;       (local.set $1
  ;;         (i32.const 3)
  ;;       )
  ;;       (local.get $3)
  ;;     )
  ;;   )
  ;; )
  ;; Here the 'block' and `local $3' are newly created to read the stacky code.
  ;; But now the 'pop' ends up nested within the 'block', which is invalid. This
  ;; test tests if this invalid code is correctly fixed up in the binary reader.
  ;; The fixup will hoist the 'pop' and create another local to store it right
  ;; after 'catch'.

  ;; CHECK:      (func $stacky-pop
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (local $1 i32)
  ;; CHECK-NEXT:  (local $2 i32)
  ;; CHECK-NEXT:  (local $3 i32)
  ;; CHECK-NEXT:  (local $4 i32)
  ;; CHECK-NEXT:  (try $label$3
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag$0
  ;; CHECK-NEXT:    (local.set $4
  ;; CHECK-NEXT:     (pop i32)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.set $2
  ;; CHECK-NEXT:     (block (result i32)
  ;; CHECK-NEXT:      (local.set $3
  ;; CHECK-NEXT:       (local.get $4)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $1
  ;; CHECK-NEXT:       (i32.const 3)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.get $3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $stacky-pop
    (local $0 i32)
    (local $1 i32)
    (local $2 i32)
    (try
      (do)
      (catch $e-i32
        (local.set $0
         (pop i32)
        )
        (local.set $1
         (i32.const 3)
        )
        (local.set $2
         (local.get $0)
        )
      )
    )
  )
)
