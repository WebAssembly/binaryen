# Verify stacky EH binary can be parsed correctly.
#
# stacky-eh.test.wasm contains below:
# try
#   nop
# catch 0 # tag type i32
#   i32.const 3
#   local.set 1
#   local.set 2
#
# (This binary was generated by
#  'wasm-opt --optimize-level=3 --generate-stack-ir -optimize-stack-ir')
#
# This code is 'stacky' in Binaryen parlance. In the binary reader, Binaryen has
# a special routine of creating a block and a local.get/local.set to read stacky
# code into Binaryen AST. So if we don't do any post-fixup, the 'catch' block
# becomes:
# (catch $e-i32
#   (local.set 2
#     (block (result i32)
#       (local.set $new
#         (pop i32)
#       )
#       (local.set 1
#         (i32.const 3)
#       )
#       (local.get $new)
#     )
#   )
# )
# Here the 'block' and `local $new' are newly created to read the stacky code.
# But now the 'pop' ends up nested within the 'block', which is invalid. This
# test tests if this invalid code is correctly fixed up in the binary reader.
# The fixup will hoist the 'pop' and create another local to store it right
# after 'catch'.

RUN: wasm-opt -all %s.wasm --print | filecheck %s

# CHECK:      (func $0
# CHECK-NEXT:  (local $0 i32)
# CHECK-NEXT:  (local $1 i32)
# CHECK-NEXT:  (local $2 i32)
# CHECK-NEXT:  (local $3 i32)
# CHECK-NEXT:  (local $4 i32)
# CHECK-NEXT:  (try $label$3
# CHECK-NEXT:   (do
# CHECK-NEXT:    (nop)
# CHECK-NEXT:   )
# CHECK-NEXT:   (catch $tag$0
# CHECK-NEXT:    (local.set $4
# CHECK-NEXT:     (pop i32)
# CHECK-NEXT:    )
# CHECK-NEXT:    (local.set $2
# CHECK-NEXT:     (block (result i32)
# CHECK-NEXT:      (local.set $3
# CHECK-NEXT:       (local.get $4)
# CHECK-NEXT:      )
# CHECK-NEXT:      (local.set $1
# CHECK-NEXT:       (i32.const 3)
# CHECK-NEXT:      )
# CHECK-NEXT:      (local.get $3)
# CHECK-NEXT:     )
# CHECK-NEXT:    )
# CHECK-NEXT:   )
# CHECK-NEXT:  )
# CHECK-NEXT: )
