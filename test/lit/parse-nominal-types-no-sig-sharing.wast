;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt --nominal -all                -S -o - | filecheck %s
;; RUN: foreach %s %t wasm-opt --nominal -all --roundtrip    -S -o - | filecheck %s
;; RUN: foreach %s %t wasm-opt --nominal -all --closed-world -S -o - | filecheck %s

;; Test that we do not use the signature cache to share a function type that
;; has a supertype. $sub appears first, so it is the earliest example of a
;; signature of no params and no results, but we should not use it as the types
;; of $foo or $bar, as it has a supertype. Instead, we should use $super as the
;; canonical type for that signature. That is fine as at least it only makes
;; $super effectively a public type, instead of both $sub and $super (the latter
;; does not validate in closed world, but the former does - the closed-world
;; run that we do here would error).
;;
;; Note that this problem only happens in nominal mode, since $sub can appear
;; before $super in the list of types.

(module
  (type $sub (func_subtype $super))

  ;; CHECK:      (type $super (func))
  (type $super (func_subtype func))

  ;; CHECK:      (global $g (ref null $super) (ref.null nofunc))
  (global $g (ref null $super) (ref.null $sub))

  ;; CHECK:      (export "foo" (func $foo))

  ;; CHECK:      (func $foo (type $super)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $foo (export "foo")
  )

  ;; CHECK:      (func $bar (type $super)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $bar
  )
)
