;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: wasm-opt %s -all -o %t.text.wast -g -S
;; RUN: wasm-as %s -all -g -o %t.wasm
;; RUN: wasm-dis %t.wasm -all -o %t.bin.wast
;; RUN: wasm-as %s -all -o %t.nodebug.wasm
;; RUN: wasm-dis %t.nodebug.wasm -all -o %t.bin.nodebug.wast
;; RUN: cat %t.text.wast | filecheck %s --check-prefix=CHECK
;; RUN: cat %t.bin.wast | filecheck %s --check-prefix=CHECK
;; RUN: cat %t.bin.nodebug.wast | filecheck %s --check-prefix=CHECK-BIN-NODEBUG

(module

 ;; Simple import
 ;; CHECK:      (import "env" "t1" (type $t1 (sub eq)))
 (import "env" "t1" (type $t1 (sub eq)))

 ;; Import with omitted typetype
 ;; CHECK:      (import "env" "t2" (type $t2 (sub any)))
 (import "env" "t2" (type $t2))

 ;; Alternative syntax with both import and export
 (type $t3 (export "t3") (import "env" "t3") (sub struct))

 ;; Use an imported type in a type
 ;; CHECK:      (import "env" "t3" (type $t3 (sub struct)))

 ;; CHECK:      (type $t4 (array (ref $t1)))
 (type $t4 (array (field (ref $t1))))

 ;; CHECK:      (type $t5 (struct (field (ref $t1))))
 (type $t5 (export "t5") (struct (field (ref $t1))))

 ;; Import function with imported types
 ;; CHECK:      (type $5 (func (param (ref $t1)) (result (ref $t2))))

 ;; CHECK:      (type $6 (func (param (ref eq) (ref $t2) (ref $t3) (ref $t4)) (result (ref $t2))))

 ;; CHECK:      (type $7 (func (param (ref $t3)) (result (ref struct))))

 ;; CHECK:      (import "env" "g" (func $g (type $5) (param (ref $t1)) (result (ref $t2))))
 (import "env" "g" (func $g (param (ref $t1)) (result (ref $t2))))

 ;; Cast and function call involving imported types
 ;; CHECK:      (export "f1" (func $f1))

 ;; CHECK:      (export "f2" (func $f2))

 ;; CHECK:      (export "t3" (type $t3))

 ;; CHECK:      (export "t5" (type $t5))

 ;; CHECK:      (export "t2" (type $t2))

 ;; CHECK:      (export "t4" (type $t4))

 ;; CHECK:      (func $f1 (type $6) (param $x (ref eq)) (param $1 (ref $t2)) (param $2 (ref $t3)) (param $3 (ref $t4)) (result (ref $t2))
 ;; CHECK-NEXT:  (call $g
 ;; CHECK-NEXT:   (ref.cast (ref $t1)
 ;; CHECK-NEXT:    (local.get $x)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $f1 (export "f1")
  (param $x (ref eq)) (param (ref $t2) (ref $t3) (ref $t4)) (result (ref $t2))
  (call $g
   (ref.cast (ref $t1)
    (local.get $x)
   )
  )
 )

 ;; Check that the imported type is a subtype of its bound
 ;; CHECK:      (func $f2 (type $7) (param $x (ref $t3)) (result (ref struct))
 ;; CHECK-NEXT:  (local.get $x)
 ;; CHECK-NEXT: )
 (func $f2 (export "f2") (param $x (ref $t3)) (result (ref struct))
  (local.get $x)
 )

 ;; Reexport an imported type
 (export "t2" (type $t2))

 ;; Export a type defined in this module
 (export "t4" (type $t4))

 ;; Export an abstract heap type
 (export "t6" (type extern))
)
;; CHECK-BIN-NODEBUG:      (import "env" "t1" (type $0 (sub eq)))

;; CHECK-BIN-NODEBUG:      (import "env" "t2" (type $1 (sub any)))

;; CHECK-BIN-NODEBUG:      (import "env" "t3" (type $2 (sub struct)))

;; CHECK-BIN-NODEBUG:      (type $3 (array (ref $0)))

;; CHECK-BIN-NODEBUG:      (type $4 (struct (field (ref $0))))

;; CHECK-BIN-NODEBUG:      (type $5 (func (param (ref $0)) (result (ref $1))))

;; CHECK-BIN-NODEBUG:      (type $6 (func (param (ref eq) (ref $1) (ref $2) (ref $3)) (result (ref $1))))

;; CHECK-BIN-NODEBUG:      (type $7 (func (param (ref $2)) (result (ref struct))))

;; CHECK-BIN-NODEBUG:      (import "env" "g" (func $fimport$0 (type $5) (param (ref $0)) (result (ref $1))))

;; CHECK-BIN-NODEBUG:      (export "f1" (func $0))

;; CHECK-BIN-NODEBUG:      (export "f2" (func $1))

;; CHECK-BIN-NODEBUG:      (export "t3" (type $2))

;; CHECK-BIN-NODEBUG:      (export "t5" (type $4))

;; CHECK-BIN-NODEBUG:      (export "t2" (type $1))

;; CHECK-BIN-NODEBUG:      (export "t4" (type $3))

;; CHECK-BIN-NODEBUG:      (func $0 (type $6) (param $0 (ref eq)) (param $1 (ref $1)) (param $2 (ref $2)) (param $3 (ref $3)) (result (ref $1))
;; CHECK-BIN-NODEBUG-NEXT:  (call $fimport$0
;; CHECK-BIN-NODEBUG-NEXT:   (ref.cast (ref $0)
;; CHECK-BIN-NODEBUG-NEXT:    (local.get $0)
;; CHECK-BIN-NODEBUG-NEXT:   )
;; CHECK-BIN-NODEBUG-NEXT:  )
;; CHECK-BIN-NODEBUG-NEXT: )

;; CHECK-BIN-NODEBUG:      (func $1 (type $7) (param $0 (ref $2)) (result (ref struct))
;; CHECK-BIN-NODEBUG-NEXT:  (local.get $0)
;; CHECK-BIN-NODEBUG-NEXT: )
