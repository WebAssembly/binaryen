;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_passes_tests_to_lit.py and could be cleaned up.

;; RUN: foreach %s %t wasm-opt --simplify-locals-nostructure -S -o - | filecheck %s

(module
  (memory 1)
  ;; CHECK:      (type $0 (func))

  ;; CHECK:      (type $1 (func (param i32 i32) (result f64)))

  ;; CHECK:      (type $2 (func (param i32) (result i32)))

  ;; CHECK:      (memory $0 1)

  ;; CHECK:      (func $contrast
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local $y i32)
  ;; CHECK-NEXT:  (local $z i32)
  ;; CHECK-NEXT:  (local $a i32)
  ;; CHECK-NEXT:  (local $b i32)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.tee $x
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (if (result i32)
  ;; CHECK-NEXT:    (i32.const 2)
  ;; CHECK-NEXT:    (then
  ;; CHECK-NEXT:     (i32.const 3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (else
  ;; CHECK-NEXT:     (i32.const 4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (i32.const 5)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 6)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $a
  ;; CHECK-NEXT:     (i32.const 7)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (local.set $a
  ;; CHECK-NEXT:     (i32.const 8)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $a)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (block $val
  ;; CHECK-NEXT:   (if
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (then
  ;; CHECK-NEXT:     (local.set $b
  ;; CHECK-NEXT:      (i32.const 11)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (br $val)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $b
  ;; CHECK-NEXT:    (i32.const 12)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $b)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $contrast ;; check for tee and structure sinking
    (local $x i32)
    (local $y i32)
    (local $z i32)
    (local $a i32)
    (local $b i32)
    (local.set $x (i32.const 1))
    (if (local.get $x) (then (nop)))
    (if (local.get $x) (then (nop)))
    (local.set $y (if (result i32) (i32.const 2) (then (i32.const 3) )(else (i32.const 4))))
    (drop (local.get $y))
    (local.set $z (block (result i32) (i32.const 5)))
    (drop (local.get $z))
    (if (i32.const 6)
      (then
        (local.set $a (i32.const 7))
      )
      (else
        (local.set $a (i32.const 8))
      )
    )
    (drop (local.get $a))
    (block $val
      (if (i32.const 10)
        (then
          (block
            (local.set $b (i32.const 11))
            (br $val)
          )
        )
      )
      (local.set $b (i32.const 12))
    )
    (drop (local.get $b))
  )
  ;; CHECK:      (func $no-unreachable
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $no-unreachable
    (local $x i32)
    (drop
      (local.tee $x
        (unreachable)
      )
    )
  )
  ;; CHECK:      (func $implicit-trap-and-global-effects
  ;; CHECK-NEXT:  (local $var$0 i32)
  ;; CHECK-NEXT:  (local.set $var$0
  ;; CHECK-NEXT:   (i32.trunc_f64_u
  ;; CHECK-NEXT:    (f64.const -nan:0xfffffffffffc3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (f32.store align=1
  ;; CHECK-NEXT:   (i32.const 22)
  ;; CHECK-NEXT:   (f32.const 154)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $var$0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $implicit-trap-and-global-effects
    (local $var$0 i32)
    (local.set $var$0
     (i32.trunc_f64_u
      (f64.const -nan:0xfffffffffffc3) ;; this implicit trap will actually trap
     )
    )
    (f32.store align=1 ;; and if we move it across this store, the store will execute, having global side effects
     (i32.const 22)
     (f32.const 154)
    )
    (drop
     (local.get $var$0)
    )
  )
  ;; CHECK:      (func $implicit-trap-and-local-effects
  ;; CHECK-NEXT:  (local $var$0 i32)
  ;; CHECK-NEXT:  (local $other i32)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (local.set $other
  ;; CHECK-NEXT:   (i32.const 100)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.trunc_f64_u
  ;; CHECK-NEXT:    (f64.const -nan:0xfffffffffffc3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $other)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $implicit-trap-and-local-effects
    (local $var$0 i32)
    (local $other i32)
    (local.set $var$0
     (i32.trunc_f64_u
      (f64.const -nan:0xfffffffffffc3) ;; this implicit trap will actually trap
     )
    )
    (local.set $other (i32.const 100)) ;; but it's fine to move it across a local effect, that vanishes anyhow
    (drop
     (local.get $var$0)
    )
    (if (i32.const 1)
     (then
      (drop
       (local.get $other)
      )
     )
    )
  )
  ;; CHECK:      (func $multi-pass-get-equivs-right (param $var$0 i32) (param $var$1 i32) (result f64)
  ;; CHECK-NEXT:  (local $var$2 i32)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (i32.store
  ;; CHECK-NEXT:   (local.get $var$0)
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (f64.promote_f32
  ;; CHECK-NEXT:   (f32.load
  ;; CHECK-NEXT:    (local.get $var$0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $multi-pass-get-equivs-right (param $var$0 i32) (param $var$1 i32) (result f64)
   (local $var$2 i32)
   (local.set $var$2
    (local.get $var$0)
   )
   (i32.store
    (local.get $var$2)
    (i32.const 1)
   )
   (f64.promote_f32
    (f32.load
     (local.get $var$2)
    )
   )
  )
  ;; CHECK:      (func $if-value-structure-equivalent (param $x i32) (result i32)
  ;; CHECK-NEXT:  (local $y i32)
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.get $x)
  ;; CHECK-NEXT: )
  (func $if-value-structure-equivalent (param $x i32) (result i32)
    (local $y i32)
    (if (i32.const 1)
      (then
        (local.set $x (i32.const 2))
      )
      (else
        (block
          (local.set $y (local.get $x))
          (local.set $x (local.get $y))
        )
      )
    )
    (local.get $x)
  )
)

