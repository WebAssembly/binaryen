;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_passes_tests_to_lit.py and could be cleaned up.

;; RUN: foreach %s %t wasm-opt --duplicate-function-elimination --all-features -S -o - | filecheck %s

;; The functions here differ in branch hints, and should not be merged.
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $b))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\00")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  (@metadata.code.branch_hint "\00")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 ;; CHECK:      (func $b (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\01")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $b (export "b") (param $x i32)
  (@metadata.code.branch_hint "\01")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

;; These also differ, now one is missing a hint, and they should not be merged.
;; TODO: Perhaps when optimizing for size, we should merge and drop the hint?
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $b))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\00")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  (@metadata.code.branch_hint "\00")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 ;; CHECK:      (func $b (type $0) (param $x i32)
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $b (export "b") (param $x i32)
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

;; Flipped case of the above, now the other one is the only one with a hint,
;; and that hint is flipped.
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $b))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 ;; CHECK:      (func $b (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\01")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $b (export "b") (param $x i32)
  (@metadata.code.branch_hint "\01")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

;; Identical branch hints: We can merge here.
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $a))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\00")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  (@metadata.code.branch_hint "\00")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 (func $b (export "b") (param $x i32)
  (@metadata.code.branch_hint "\00")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

;; Ditto, with identical hints of 1.
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $a))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  (@metadata.code.branch_hint "\01")
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  (@metadata.code.branch_hint "\01")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 (func $b (export "b") (param $x i32)
  (@metadata.code.branch_hint "\01")
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

;; Source file location (debug info) does *not* prevent optimization. We
;; prioritize optimization over debug info quality.
(module
 ;; CHECK:      (type $0 (func (param i32)))

 ;; CHECK:      (export "a" (func $a))

 ;; CHECK:      (export "b" (func $a))

 ;; CHECK:      (func $a (type $0) (param $x i32)
 ;; CHECK-NEXT:  ;;@ src.cpp:10:1
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (then
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $a (export "a") (param $x i32)
  ;; After we merge, this hint will remain in the single function.
  ;;@ src.cpp:10:1
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )

 (func $b (export "b") (param $x i32)
  ;;@ src.cpp:20:1
  (if
   (local.get $x)
   (then
    (unreachable)
   )
  )
 )
)

