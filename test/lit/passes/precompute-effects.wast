;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.

;; RUN: wasm-opt %s --remove-unused-names --precompute-propagate --fuzz-exec -all -S -o - \
;; RUN:   | filecheck %s

(module
 ;; CHECK:      (global $g (mut i32) (i32.const 10))
 (global $g (mut i32) (i32.const 10))

 ;; CHECK:      (func $loop (type $0)
 ;; CHECK-NEXT:  (local $temp i32)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (i32.const 10)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $loop
  (local $temp i32)
  ;; We should not try to precompute this loop. If we attempted to replace it
  ;; with its children, we'd need to handle the effects of chidren properly,
  ;; which we do not do in this pass.
  (loop
   (local.set $temp
    (i32.const 10)
   )
  )
 )

 ;; CHECK:      (func $local.set (type $0)
 ;; CHECK-NEXT:  (local $temp i32)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (i32.const 10)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.tee $temp
 ;; CHECK-NEXT:    (i32.const 20)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $local.set
  (local $temp i32)
  ;; We should not try to precompute a set or tee.
  (local.set $temp
   (i32.const 10)
  )
  (drop
   (local.tee $temp
    (i32.const 20)
   )
  )
 )

 ;; CHECK:      (func $global.set (type $0)
 ;; CHECK-NEXT:  (global.set $g
 ;; CHECK-NEXT:   (i32.const 20)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $global.set
  ;; We should not try to precompute a global set.
  (global.set $g
   (i32.const 20)
  )
 )

 ;; CHECK:      (func $binary-tee (type $1) (result i32)
 ;; CHECK-NEXT:  (local $temp i32)
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.tee $temp
 ;; CHECK-NEXT:    (i32.const 10)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (i32.const 20)
 ;; CHECK-NEXT: )
 (func $binary-tee (result i32)
  (local $temp i32)
  ;; We can precompute this and remove the add, but must keep the tee.
  (i32.add
   (local.tee $temp
    (i32.const 10)
   )
   (local.get $temp)
  )
 )

 ;; CHECK:      (func $binary-both (type $1) (result i32)
 ;; CHECK-NEXT:  (local $temp i32)
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.tee $temp
 ;; CHECK-NEXT:    (i32.const 10)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.tee $temp
 ;; CHECK-NEXT:    (i32.const 20)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (i32.const 30)
 ;; CHECK-NEXT: )
 (func $binary-both (result i32)
  (local $temp i32)
  ;; Now we must keep both tees.
  (i32.add
   (local.tee $temp
    (i32.const 10)
   )
   (local.tee $temp
    (i32.const 20)
   )
  )
 )

 ;; CHECK:      (func $nested-global (type $1) (result i32)
 ;; CHECK-NEXT:  (local $temp i32)
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block (result i32)
 ;; CHECK-NEXT:    (local.set $temp
 ;; CHECK-NEXT:     (i32.const 10)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (i32.const 20)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block (result i32)
 ;; CHECK-NEXT:    (global.set $g
 ;; CHECK-NEXT:     (i32.const 30)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (i32.const 40)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (i32.const 60)
 ;; CHECK-NEXT: )
 (func $nested-global (result i32)
  (local $temp i32)
  ;; Nested effects inside arms, and one is a global effect.
  (i32.add
   (block (result i32)
    (local.set $temp
     (i32.const 10)
    )
    (i32.const 20)
   )
   (block (result i32)
    (global.set $g
     (i32.const 30)
    )
    (i32.const 40)
   )
  )
 )
)

;; TODO: more from current PR

