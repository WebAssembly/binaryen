;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --heap2local -S -o - | filecheck %s

(module
  (type $struct.A (struct (field i32)))

  ;; CHECK:      (func $simple
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct.A))
  ;; CHECK-NEXT:    (local.set $0
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $simple
    ;; Other passes can remove such a simple case of an unneeded allocation, but
    ;; out analysis should definitely handle something so simple. (We do end up
    ;; emitting a bunch of extra code here, increasing code size, but other
    ;; optimizations can remove it.)
    (drop
      (struct.new_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
    )
  )

  ;; CHECK:      (func $to-local
  ;; CHECK-NEXT:  (local $ref (ref null $struct.A))
  ;; CHECK-NEXT:  (local $1 i32)
  ;; CHECK-NEXT:  (local $2 i32)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct.A))
  ;; CHECK-NEXT:    (local.set $2
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $to-local
    (local $ref (ref null $struct.A))
    ;; Other passes cannot remove an allocation that is written to a local, but
    ;; we can, since it does not escape.
    (local.set $ref
      (struct.new_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
    )
  )
)
