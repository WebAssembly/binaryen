;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --heap2local -S -o - | filecheck %s

(module
  (type $struct.A (struct (field (mut i32)) (field (mut f64))))

  (type $struct.packed (struct (field (mut i8))))

  (type $struct.nondefaultable (struct (field (rtt $struct.A))))

  ;; CHECK:      (func $simple
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:    (rtt.canon $struct.A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $simple
    ;; Other passes can remove such a simple case of an unneeded allocation, and
    ;; we do not bother with it, as there are struct get/set operations that we
    ;; can optimize out.
    (drop
      (struct.new_default_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
    )
  )

  ;; CHECK:      (func $to-local
  ;; CHECK-NEXT:  (local $ref (ref null $struct.A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:    (rtt.canon $struct.A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $to-local
    (local $ref (ref null $struct.A))
    ;; While set to a local, this allocation has no get/set operations, so we
    ;; ignore it.
    (local.set $ref
      (struct.new_default_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
    )
  )

  ;; CHECK:      (func $one-get
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (local $1 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref $struct.A))
  ;; CHECK-NEXT:      (local.set $0
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $1
  ;; CHECK-NEXT:       (f64.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:       (rtt.canon $struct.A)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $one-get
    ;; An allocation followed by an immediate get of a field. This is a non-
    ;; escaping allocation, with a use, so we can optimize it out. The
    ;; allocation is dropped (letting later opts remove it), and the allocation's
    ;; data is moved to locals: we write the initial value to the locals, and
    ;; we read from the locals instead of the struct.get.
    (drop
      (struct.get $struct.A 0
        (struct.new_default_with_rtt $struct.A
          (rtt.canon $struct.A)
        )
      )
    )
  )

  ;; CHECK:      (func $one-get-b
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (local $1 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref $struct.A))
  ;; CHECK-NEXT:      (local.set $0
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $1
  ;; CHECK-NEXT:       (f64.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:       (rtt.canon $struct.A)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $one-get-b
    ;; Similar to the above, but using a different field index.
    (drop
      (struct.get $struct.A 1
        (struct.new_default_with_rtt $struct.A
          (rtt.canon $struct.A)
        )
      )
    )
  )

  ;; CHECK:      (func $one-set
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (local $1 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct.A))
  ;; CHECK-NEXT:    (local.set $0
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.set $1
  ;; CHECK-NEXT:     (f64.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $0
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $one-set
    ;; A simple optimizable allocation only used in one set.
    (struct.set $struct.A 0
      (struct.new_default_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
      (i32.const 1)
    )
  )

  ;; CHECK:      (func $packed
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get_u $struct.packed 0
  ;; CHECK-NEXT:    (struct.new_default_with_rtt $struct.packed
  ;; CHECK-NEXT:     (rtt.canon $struct.packed)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $packed
    ;; We do not optimize packed structs yet.
    (drop
      (struct.get $struct.packed 0
        (struct.new_default_with_rtt $struct.packed
          (rtt.canon $struct.packed)
        )
      )
    )
  )

  ;; CHECK:      (func $with-init-values
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (local $1 f64)
  ;; CHECK-NEXT:  (local $2 i32)
  ;; CHECK-NEXT:  (local $3 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref $struct.A))
  ;; CHECK-NEXT:      (local.set $2
  ;; CHECK-NEXT:       (i32.const 2)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $3
  ;; CHECK-NEXT:       (f64.const 3.14159)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $0
  ;; CHECK-NEXT:       (local.get $2)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $1
  ;; CHECK-NEXT:       (local.get $3)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (struct.new_with_rtt $struct.A
  ;; CHECK-NEXT:       (local.get $0)
  ;; CHECK-NEXT:       (local.get $1)
  ;; CHECK-NEXT:       (rtt.canon $struct.A)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $with-init-values
    ;; When we get values to initialize the struct with, assign them to the
    ;; proper locals.
    (drop
      (struct.get $struct.A 0
        (struct.new_with_rtt $struct.A
          (i32.const 2)
          (f64.const 3.14159)
          (rtt.canon $struct.A)
        )
      )
    )
  )

  ;; CHECK:      (func $nondefaultable
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct.nondefaultable 0
  ;; CHECK-NEXT:    (struct.new_with_rtt $struct.nondefaultable
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:     (rtt.canon $struct.nondefaultable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nondefaultable
    ;; We do not optimize structs with nondefaultable types that we cannot
    ;; handle, like rtts.
    (drop
      (struct.get $struct.nondefaultable 0
        (struct.new_with_rtt $struct.nondefaultable
          (rtt.canon $struct.A)
          (rtt.canon $struct.nondefaultable)
        )
      )
    )
  )

  ;; CHECK:      (func $one-set-one-local
  ;; CHECK-NEXT:  (local $ref (ref null $struct.A))
  ;; CHECK-NEXT:  (local $1 i32)
  ;; CHECK-NEXT:  (local $2 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct.A))
  ;; CHECK-NEXT:    (local.set $1
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.set $2
  ;; CHECK-NEXT:     (f64.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default_with_rtt $struct.A
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (block
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $1
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $one-set-one-local
    (local $ref (ref null $struct.A))
    ;; A simple optimizable allocation only used in one set, and also stored
    ;; to a local. The local.set should not prevent our optimization, and the
    ;; local.set can be turned into a drop.
    (local.set $ref
      (struct.new_default_with_rtt $struct.A
        (rtt.canon $struct.A)
      )
    )
    (struct.set $struct.A 0
      (local.get $ref)
      (i32.const 1)
    )
  )

  ;; FIXME
  ;; CHECK:      (func $with-init-values-loop
  ;; CHECK-NEXT:  (local $ref (ref null $struct.A))
  ;; CHECK-NEXT:  (loop $loop
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new_with_rtt $struct.A
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:     (block $block (result f64)
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $struct.A 0
  ;; CHECK-NEXT:        (local.get $ref)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (f64.const 2.1828)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (rtt.canon $struct.A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $with-init-values-loop
    (local $ref (ref null $struct.A))
    ;; A testcase showing why we need extra temp locals when assigning
    ;; the initial values: they must all be present at once when the
    ;; "allocation" happens, as the local might be used before.
    (loop $loop
      (local.set $ref
        (struct.new_with_rtt $struct.A
          (i32.const 2)
          (block (result f64)
            ;; imagine that we check if the reference is not null here, and if
            ;; not then we read from the struct.
            (drop
              ;; A get from the struct. This should return the old value,
              ;; before the assignment of "2" a few lines above us
              (struct.get $struct.A 0
                (local.get $ref)
              )
            )
            (f64.const 2.1828)
          )
          (rtt.canon $struct.A)
        )
        (struct.set $struct.A 0
          (local.get $ref)
          (i32.const 3)
        )
      )
    )
  )
)
