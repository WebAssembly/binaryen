;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --remove-unused-names --optimize-instructions -all -S -o - \
;; RUN:   | filecheck %s
;;
;; --remove-unused-names allows the optimizer to see that the blocks have no
;; breaks to them, and so they have no nonlinear control flow.

(module
  ;; CHECK:      (type $struct2 (struct (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (type $struct (struct (field (mut i32))))
  (type $struct (struct (field (mut i32))))

  (type $struct2 (struct (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (func $tee
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $tee
    (local $ref (ref null $struct))
    ;; The set is not needed as we can apply the 20 in the new.
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $side-effects-in-old-value
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $helper-i32
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effects-in-old-value
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          ;; Side effects here force us to keep the old value around.
          (call $helper-i32 (i32.const 0))
        )
      )
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $side-effects-in-new-value
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (call $helper-i32
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effects-in-new-value
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      ;; Side effects here are not a problem.
      (call $helper-i32 (i32.const 0))
    )
  )

  ;; CHECK:      (func $many-fields
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 40)
  ;; CHECK-NEXT:    (i32.const 60)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $many-fields
    (local $ref (ref null $struct2))
    ;; Set to the first field.
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          (i32.const 10)
          (i32.const 20)
        )
      )
      (i32.const 30)
    )
    ;; Set to the second.
    (struct.set $struct2 1
      (local.tee $ref
        (struct.new $struct2
          (i32.const 40)
          (i32.const 50)
        )
      )
      (i32.const 60)
    )
  )

  ;; CHECK:      (func $side-effect-conflict
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.tee $ref
  ;; CHECK-NEXT:    (struct.new $struct2
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (call $helper-i32
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call $helper-i32
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effect-conflict
    (local $ref (ref null $struct2))
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          (i32.const 10)
          ;; Side effects on the second field prevent us from moving the set's
          ;; value past it to replace the first field above it.
          (call $helper-i32 (i32.const 0))
        )
      )
      (call $helper-i32 (i32.const 1))
    )
  )

  ;; CHECK:      (func $side-effect-ok
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $helper-i32
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (call $helper-i32
  ;; CHECK-NEXT:      (i32.const 1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effect-ok
    (local $ref (ref null $struct2))
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          ;; Side effects on the first field do not interfere.
          (call $helper-i32 (i32.const 0))
          (i32.const 10)
        )
      )
      (call $helper-i32 (i32.const 1))
    )
  )





















;; TODO

  ;; CHECK:      (func $optimize-chain
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 30)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $optimize-chain
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
    ;; The value in the last item in the chain should apply.
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 30)
    )
  )


  ;; CHECK:      (func $local-written
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $local-written
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    ;; Writing to the local containing the reference prevents optimization.
    (local.set $ref
      (ref.null $struct)
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $other-local-written
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local $ref-other (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref-other
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $other-local-written
    (local $ref (ref null $struct))
    (local $ref-other (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    ;; Writing to another local does not bother us.
    (local.set $ref-other
      (ref.null $struct)
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
  )


  ;; CHECK:      (func $multiple-fields
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 100)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 200)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $multiple-fields
    (local $ref (ref null $struct2))
    (local.set $ref
      (struct.new $struct2
        (i32.const 10)
        (i32.const 20)
      )
    )
    (struct.set $struct2 0
      (local.get $ref)
      (i32.const 100)
    )
    (struct.set $struct2 1
      (local.get $ref)
      (i32.const 200)
    )
  )

  ;; CHECK:      (func $side-effects-conflict
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (local.set $x
  ;; CHECK-NEXT:      (i32.const -1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (local.set $x
  ;; CHECK-NEXT:      (i32.const -2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 100)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 200)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effects-conflict
    (local $ref (ref null $struct2))
    (local $x i32)
    ;; Side effects in all 4 values here prevent us from optimizing.
    ;; We can't optimize the first set because it would cross the new's second
    ;; value, and we can't optimize the second set because the first set is in
    ;; the middle.
    (local.set $ref
      (struct.new $struct2
        (block (result i32)
          (local.set $x
            (i32.const -1)
          )
          (i32.const 10)
        )
        (block (result i32)
          (local.set $x
            (i32.const -2)
          )
          (i32.const 20)
        )
      )
    )
    (struct.set $struct2 0
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -3)
        )
        (i32.const 100)
      )
    )
    (struct.set $struct2 1
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -4)
        )
        (i32.const 200)
      )
    )
  )

  ;; CHECK:      (func $side-effects-conflict-1
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (local.set $x
  ;; CHECK-NEXT:      (i32.const -2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 100)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 200)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effects-conflict-1
    (local $ref (ref null $struct2))
    (local $x i32)
    ;; As above, but without the first side effect. This does not allow any more
    ;; optimization than before.
    (local.set $ref
      (struct.new $struct2
        (i32.const 10)
        (block (result i32)
          (local.set $x
            (i32.const -2)
          )
          (i32.const 20)
        )
      )
    )
    (struct.set $struct2 0
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -3)
        )
        (i32.const 100)
      )
    )
    (struct.set $struct2 1
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -4)
        )
        (i32.const 200)
      )
    )
  )

  ;; CHECK:      (func $side-effects-conflict-2
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (local.set $x
  ;; CHECK-NEXT:      (i32.const -2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 100)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const -4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 200)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $side-effects-conflict-2
    (local $ref (ref null $struct2))
    (local $x i32)
    ;; As above, but without the second side effect. This *does* allow us to
    ;; do optimization.
    (local.set $ref
      (struct.new $struct2
        (block (result i32)
          (local.set $x
            (i32.const -2)
          )
          (i32.const 10)
        )
        (i32.const 20)
      )
    )
    (struct.set $struct2 0
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -3)
        )
        (i32.const 100)
      )
    )
    (struct.set $struct2 1
      (local.get $ref)
      (block (result i32)
        (local.set $x
          (i32.const -4)
        )
        (i32.const 200)
      )
    )
  )

  ;; CHECK:      (func $helper-i32 (param $x i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: )
  (func $helper-i32 (param $x i32) (result i32)
    (i32.const 42)
  )
)
