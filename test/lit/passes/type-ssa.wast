;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt --type-ssa -all -S -o - | filecheck %s

;; Test in both isorecursive and nominal modes to make sure we create the new
;; types properly in both.

;; Every struct.new here should get a new type.
(module
  ;; CHECK:      (type $struct (struct (field i32)))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $struct$1 (sub $struct (struct (field i32))))

  ;; CHECK:       (type $struct$2 (sub $struct (struct (field i32))))

  ;; CHECK:       (type $struct$3 (sub $struct (struct (field i32))))

  ;; CHECK:       (type $struct$4 (sub $struct (struct (field i32))))

  ;; CHECK:       (type $struct$5 (sub $struct (struct (field i32))))

  ;; CHECK:      (global $g (ref $struct) (struct.new $struct$4
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: ))
  (global $g (ref $struct) (struct.new $struct
    (i32.const 42)
  ))

  ;; CHECK:      (global $h (ref $struct) (struct.new $struct$5
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: ))
  (global $h (ref $struct) (struct.new $struct
    (i32.const 42)
  ))

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $struct$1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct$2
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo
    (drop
      (struct.new_default $struct)
    )
    (drop
      (struct.new $struct
        (i32.const 10)
      )
    )
  )

  ;; CHECK:      (func $another-func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct$3
  ;; CHECK-NEXT:    (i32.const 100)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $another-func
    (drop
      (struct.new $struct
        (i32.const 100)
      )
    )
  )
)

;; The same module as before, except that now the type is final, so we cannot
;; create any subtypes.
(module
  ;; CHECK:      (type $struct (sub final (struct (field i32))))
  (type $struct (sub final (struct (field i32))))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (global $g (ref $struct) (struct.new $struct
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: ))
  (global $g (ref $struct) (struct.new $struct
    (i32.const 42)
  ))

  ;; CHECK:      (global $h (ref $struct) (struct.new $struct
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: ))
  (global $h (ref $struct) (struct.new $struct
    (i32.const 42)
  ))

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo
    (drop
      (struct.new_default $struct)
    )
    (drop
      (struct.new $struct
        (i32.const 10)
      )
    )
  )

  ;; CHECK:      (func $another-func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 100)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $another-func
    (drop
      (struct.new $struct
        (i32.const 100)
      )
    )
  )
)

;; Some of these are uninteresting and should not get a new type.
(module

  ;; CHECK:      (type $anyref_arrayref_=>_none (func (param anyref arrayref)))

  ;; CHECK:      (type $struct (struct (field anyref)))
  (type $struct (struct_subtype (field (ref null any)) data))

  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $struct$1 (sub $struct (struct (field anyref))))

  ;; CHECK:       (type $struct$2 (sub $struct (struct (field anyref))))

  ;; CHECK:       (type $struct$3 (sub $struct (struct (field anyref))))

  ;; CHECK:      (func $foo (type $anyref_arrayref_=>_none) (param $any anyref) (param $array arrayref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $struct$1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct$2
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (local.get $any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct$3
  ;; CHECK-NEXT:    (local.get $array)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (param $any (ref null any)) (param $array (ref null array))
    ;; A null is interesting.
    (drop
      (struct.new_default $struct)
    )
    (drop
      (struct.new $struct
        (ref.null none)
      )
    )
    ;; An unknown value of the same type is uninteresting.
    (drop
      (struct.new $struct
        (local.get $any)
      )
    )
    ;; But a more refined type piques our interest.
    (drop
      (struct.new $struct
        (local.get $array)
      )
    )
    ;; An unreachable is boring.
    (drop
      (struct.new $struct
        (unreachable)
      )
    )
  )
)

(module
  ;; CHECK:      (type $array (array (mut anyref)))
  (type $array (array (mut (ref null any))))

  ;; CHECK:      (type $ref|i31|_anyref_=>_none (func (param (ref i31) anyref)))

  ;; CHECK:      (type $array-func (array (mut funcref)))
  (type $array-func (array (mut funcref)))

  (elem func $array.new)

  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $array$1 (sub $array (array (mut anyref))))

  ;; CHECK:       (type $array$2 (sub $array (array (mut anyref))))

  ;; CHECK:       (type $array$3 (sub $array (array (mut anyref))))

  ;; CHECK:       (type $array-func$4 (sub $array-func (array (mut funcref))))

  ;; CHECK:       (type $array$5 (sub $array (array (mut anyref))))

  ;; CHECK:       (type $array$6 (sub $array (array (mut anyref))))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (elem $0 func $array.new)

  ;; CHECK:      (func $array.new (type $ref|i31|_anyref_=>_none) (param $refined (ref i31)) (param $null-any anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_default $array$1
  ;; CHECK-NEXT:    (i32.const 5)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new $array$2
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:    (i32.const 5)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new $array$3
  ;; CHECK-NEXT:    (local.get $refined)
  ;; CHECK-NEXT:    (i32.const 5)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new $array
  ;; CHECK-NEXT:    (local.get $null-any)
  ;; CHECK-NEXT:    (i32.const 5)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $array.new (param $refined (ref i31)) (param $null-any (ref null any))
    ;; Default null, an interesting value, so we get a new type.
    (drop
      (array.new_default $array
        (i32.const 5)
      )
    )
    ;; Given null, also interesting.
    (drop
      (array.new $array
        (ref.null none)
        (i32.const 5)
      )
    )
    ;; More refined type, interesting.
    (drop
      (array.new $array
        (local.get $refined)
        (i32.const 5)
      )
    )
    ;; Same type as declared - boring, no new type.
    (drop
      (array.new $array
        (local.get $null-any)
        (i32.const 5)
      )
    )
  )

  ;; CHECK:      (func $array.new_seg (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_elem $array-func$4 $0
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:    (i32.const 3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $array.new_seg
    ;; We consider all new_elem to be interesting as we don't look at the elem
    ;; data yet.
    (drop
      (array.new_elem $array-func 0
        (i32.const 0)
        (i32.const 3)
      )
    )
  )

  ;; CHECK:      (func $array.new_fixed (type $ref|i31|_anyref_=>_none) (param $refined (ref i31)) (param $null-any anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_fixed $array$5 1
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_fixed $array$6 1
  ;; CHECK-NEXT:    (local.get $refined)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_fixed $array 1
  ;; CHECK-NEXT:    (local.get $null-any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_fixed $array 2
  ;; CHECK-NEXT:    (local.get $refined)
  ;; CHECK-NEXT:    (local.get $null-any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $array.new_fixed (param $refined (ref i31)) (param $null-any (ref null any))
    ;; Null, interesting, so we get a new type.
    (drop
      (array.new_fixed $array 1
        (ref.null none)
      )
    )
    ;; More refined type, interesting.
    (drop
      (array.new_fixed $array 1
        (local.get $refined)
      )
    )
    ;; Same type as declared - boring, no new type.
    (drop
      (array.new_fixed $array 1
        (local.get $null-any)
      )
    )
    ;; Mixture of boring and interesting => boring (since we infer a single type
    ;; for the entire array).
    (drop
      (array.new_fixed $array 2
        (local.get $refined)
        (local.get $null-any)
      )
    )
  )
)

;; Test that we do not error on externalized/internalized data. As we process
;; the fields of $struct we check if they are constants that we can handle, and
;; we should not hit any asserts while doing so. After that, we will decide not
;; to optimize $struct, since the global contains a struct.new (which we cannot
;; turn into a simple Literal). (We do optimize $empty and generate $empty$1,
;; but that is not important here.)
(module
  ;; CHECK:      (type $empty (struct ))
  (type $empty (struct))

  ;; CHECK:      (type $empty$1 (sub $empty (struct )))

  ;; CHECK:      (type $anyref_=>_none (func (param anyref)))

  ;; CHECK:      (type $struct (struct (field externref) (field anyref) (field externref)))
  (type $struct (struct externref anyref externref))

  ;; CHECK:      (global $g (mut anyref) (struct.new_default $empty$1))
  (global $g (mut anyref) (struct.new $empty))

  ;; CHECK:      (func $0 (type $anyref_=>_none) (param $param anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (extern.externalize
  ;; CHECK-NEXT:     (global.get $g)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (extern.internalize
  ;; CHECK-NEXT:     (extern.externalize
  ;; CHECK-NEXT:      (global.get $g)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (extern.externalize
  ;; CHECK-NEXT:     (local.get $param)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $0 (param $param anyref)
    (drop
      (struct.new $struct
        ;; An externalized global.
        (extern.externalize
          (global.get $g)
        )
        ;; An externalized and then internalized global.
        (extern.internalize
          (extern.externalize
            (global.get $g)
          )
        )
        ;; An externalized parameter.
        (extern.externalize
          (local.get $param)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $array (array (mut f32)))
  (type $array (array (mut f32)))

  ;; CHECK:      (type $subarray (sub $array (array (mut f32))))
  (type $subarray (array_subtype (mut f32) $array))

  ;; CHECK:      (type $ref|$subarray|_=>_none (func (param (ref $subarray))))

  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $array$1 (sub $array (array (mut f32))))

  ;; CHECK:       (type ${mut:i32_mut:i32_mut:f64_mut:f64_mut:i32_mut:f64_mut:f64_mut:i32_mut:i32_mut:i32_mut:i32} (struct (field (mut i32)) (field (mut i32)) (field (mut f64)) (field (mut f64)) (field (mut i32)) (field (mut f64)) (field (mut f64)) (field (mut i32)) (field (mut i32)) (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (func $1 (type $ref|$subarray|_=>_none) (param $ref (ref $subarray))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (array.new_default $array$1
  ;; CHECK-NEXT:    (i32.const 64)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $1 (param $ref (ref $subarray))
    ;; TypeSSA will create another subtype of array, which will happen to
    ;; conflict with $subarray. We will need to create a new "weird" rec group
    ;; with a "hash" in it to avoid the conflict.
    (drop
      (array.new_default $array
        (i32.const 64)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct ))
  (type $A (struct ))

  ;; CHECK:      (type $A$1 (sub $A (struct )))

  ;; CHECK:      (type $none_=>_ref|$A| (func (result (ref $A))))

  ;; CHECK:      (func $0 (type $none_=>_ref|$A|) (result (ref $A))
  ;; CHECK-NEXT:  (block $label (result (ref $A$1))
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (br_on_cast $label (ref $A$1) (ref $A$1)
  ;; CHECK-NEXT:     (struct.new_default $A$1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $0 (result (ref $A))
    ;; After creating a subtype of $A as the input to the br_on_cast, the cast
    ;; must be refinalized so that it validates (otherwise, it would try to cast
    ;; to a supertype).
    (block $label (result (ref $A))
      (drop
        (br_on_cast $label (ref $A) (ref $A)
          (struct.new_default $A)
        )
      )
      (unreachable)
    )
  )
)
