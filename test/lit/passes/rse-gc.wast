;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --rse -all -S -o - | filecheck %s

(module
 ;; CHECK:      (type $B (struct (field (ref data))))

 ;; CHECK:      (type $A (struct (field dataref)))
 (type $A (struct_subtype (field (ref null data)) data))

 ;; $B is a subtype of $A, and its field has a more refined type (it is non-
 ;; nullable).
 (type $B (struct_subtype (field (ref data)) $A))

 ;; CHECK:      (func $test
 ;; CHECK-NEXT:  (local $single (ref func))
 ;; CHECK-NEXT:  (local $tuple ((ref any) (ref any)))
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $test
  ;; A non-nullable local. The pass should ignore it (as we cannot optimize
  ;; anything here anyhow: the code must assign to the local before reading from
  ;; it, so no sets can be redundant in that sense).
  (local $single (ref func))
  ;; A non-nullable tuple.
  (local $tuple ((ref any) (ref any)))
 )

 ;; CHECK:      (func $needs-refinalize (param $b (ref $B)) (result anyref)
 ;; CHECK-NEXT:  (local $a (ref null $A))
 ;; CHECK-NEXT:  (local.set $a
 ;; CHECK-NEXT:   (local.get $b)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (struct.get $B 0
 ;; CHECK-NEXT:   (local.get $b)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $needs-refinalize (param $b (ref $B)) (result anyref)
  (local $a (ref null $A))
  ;; Make $a contain $b.
  (local.set $a
    (local.get $b)
  )
  (struct.get $A 0
   ;; Once more, make $a contain $b. This set is redundant. After removing it,
   ;; the struct.get will be reading from type $B, which has a more refined
   ;; field, so we must refinalize to get the right type for the instruction.
   (local.tee $a
    (local.get $b)
   )
  )
 )

 ;; CHECK:      (func $pick-refined (param $A (ref null $A)) (param $x i32)
 ;; CHECK-NEXT:  (local $B (ref null $B))
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (ref.cast_static $B
 ;; CHECK-NEXT:    (local.get $B)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $B)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $B)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (local.get $B)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (local.get $B)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $B)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $B)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $pick-refined (param $A (ref null $A)) (param $x i32)
  (local $B (ref null $B))
  (local.set $B
   (ref.cast_static $B
    (local.get $A)
   )
  )
  ;; All these can refer to $B, the more refined type, even in branching and
  ;; merging control flow later.
  (drop
   (local.get $A)
  )
  (drop
   (local.get $B)
  )
  (if
   (local.get $x)
   (drop
    (local.get $A)
   )
   (drop
    (local.get $B)
   )
  )
  (drop
   (local.get $A)
  )
  (drop
   (local.get $B)
  )
 )

 ;; CHECK:      (func $pick-refined-nn (param $A (ref $A)) (param $x i32)
 ;; CHECK-NEXT:  (local $B (ref null $B))
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (ref.cast_static $B
 ;; CHECK-NEXT:    (ref.as_non_null
 ;; CHECK-NEXT:     (local.get $B)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (ref.as_non_null
 ;; CHECK-NEXT:    (local.get $B)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (ref.as_non_null
 ;; CHECK-NEXT:    (local.get $B)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $pick-refined-nn (param $A (ref $A)) (param $x i32)
  (local $B (ref $B))
  ;; As above, but now the types are both non-nullable. We should still switch
  ;; to $B.
  (local.set $B
   (ref.cast_static $B
    (local.get $A)
   )
  )
  (drop
   (local.get $A)
  )
  (drop
   (local.get $B)
  )
 )

 ;; CHECK:      (func $avoid-unrefined (param $A (ref $A)) (param $x i32)
 ;; CHECK-NEXT:  (local $B (ref null $B))
 ;; CHECK-NEXT:  (local.set $B
 ;; CHECK-NEXT:   (ref.cast_static $B
 ;; CHECK-NEXT:    (local.get $A)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $A)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $B)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $avoid-unrefined (param $A (ref $A)) (param $x i32)
  (local $B (ref null $B))
  ;; As above, but now the local is nullable. Since the parameter is non-
  ;; nullable, that means neither is a subtype of the other, and we will make
  ;; no changes.
  (local.set $B
   (ref.cast_static $B
    (local.get $A)
   )
  )
  (drop
   (local.get $A)
  )
  (drop
   (local.get $B)
  )
 )

 ;; CHECK:      (func $pick-refined-earlier (param $A (ref $A)) (param $x i32)
 ;; CHECK-NEXT:  (local $A2 (ref null $A))
 ;; CHECK-NEXT:  (local.set $A2
 ;; CHECK-NEXT:   (local.get $A)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $A)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (local.get $A)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $pick-refined-earlier (param $A (ref $A)) (param $x i32)
  ;; As above but now the local has the same heap type but is nullable. Now we
  ;; prefer the non-nullable parameter.
  (local $A2 (ref null $A))
  (local.set $A2
   (local.get $A)
  )
  (drop
   (local.get $A)
  )
  (drop
   (local.get $A2)
  )
 )
)
