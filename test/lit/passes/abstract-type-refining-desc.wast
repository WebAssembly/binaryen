;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt --abstract-type-refining --remove-unused-types --traps-never-happen \
;; RUN:     -all --closed-world --preserve-type-order -S -o - | filecheck %s --check-prefix=YESTNH
;; RUN: foreach %s %t wasm-opt --abstract-type-refining --remove-unused-types \
;; RUN:     -all --closed-world --preserve-type-order -S -o - | filecheck %s --check-prefix=NO_TNH

;; Run in both TNH and non-TNH mode.

(module
  ;; We should not try to generate invalid types by removing the subtype
  ;; relation between $B.desc and $A.desc.
  (rec
    ;; YESTNH:      (rec
    ;; YESTNH-NEXT:  (type $A (sub (descriptor $A.desc (struct))))
    ;; NO_TNH:      (rec
    ;; NO_TNH-NEXT:  (type $A (sub (descriptor $A.desc (struct))))
    (type $A (sub (descriptor $A.desc (struct))))
    ;; YESTNH:       (type $A.desc (sub (describes $A (struct))))
    ;; NO_TNH:       (type $A.desc (sub (describes $A (struct))))
    (type $A.desc (sub (describes $A (struct))))
    ;; YESTNH:       (type $B (sub $A (descriptor $B.desc (struct))))
    ;; NO_TNH:       (type $B (sub $A (descriptor $B.desc (struct))))
    (type $B (sub $A (descriptor $B.desc (struct))))
    ;; YESTNH:       (type $B.desc (sub $A.desc (describes $B (struct))))
    ;; NO_TNH:       (type $B.desc (sub $A.desc (describes $B (struct))))
    (type $B.desc (sub $A.desc (describes $B (struct))))
  )
  ;; YESTNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; YESTNH-NEXT:  (ref.null none)
  ;; YESTNH-NEXT: ))
  ;; NO_TNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; NO_TNH-NEXT:  (ref.null none)
  ;; NO_TNH-NEXT: ))
  (global $g (ref (exact $B))
    (struct.new_default $B
      (ref.null none)
    )
  )
)
