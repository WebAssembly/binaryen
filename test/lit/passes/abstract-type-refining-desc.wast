;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt --abstract-type-refining --remove-unused-types --traps-never-happen \
;; RUN:     -all --closed-world --preserve-type-order -S -o - | filecheck %s --check-prefix=YESTNH
;; RUN: foreach %s %t wasm-opt --abstract-type-refining --remove-unused-types \
;; RUN:     -all --closed-world --preserve-type-order -S -o - | filecheck %s --check-prefix=NO_TNH

;; Run in both TNH and non-TNH mode.

(module
  ;; We should not try to generate invalid types by removing the subtype
  ;; relation between $B.desc and $A.desc.
  (rec
    ;; YESTNH:      (rec
    ;; YESTNH-NEXT:  (type $A (sub (descriptor $A.desc (struct))))
    ;; NO_TNH:      (rec
    ;; NO_TNH-NEXT:  (type $A (sub (descriptor $A.desc (struct))))
    (type $A (sub (descriptor $A.desc (struct))))
    ;; YESTNH:       (type $A.desc (sub (describes $A (struct))))
    ;; NO_TNH:       (type $A.desc (sub (describes $A (struct))))
    (type $A.desc (sub (describes $A (struct))))
    ;; YESTNH:       (type $B (sub $A (descriptor $B.desc (struct))))
    ;; NO_TNH:       (type $B (sub $A (descriptor $B.desc (struct))))
    (type $B (sub $A (descriptor $B.desc (struct))))
    ;; YESTNH:       (type $B.desc (sub $A.desc (describes $B (struct))))
    ;; NO_TNH:       (type $B.desc (sub $A.desc (describes $B (struct))))
    (type $B.desc (sub $A.desc (describes $B (struct))))
  )
  ;; YESTNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; YESTNH-NEXT:  (ref.null none)
  ;; YESTNH-NEXT: ))
  ;; NO_TNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; NO_TNH-NEXT:  (ref.null none)
  ;; NO_TNH-NEXT: ))
  (global $g (ref (exact $B))
    (struct.new_default $B
      (ref.null none)
    )
  )
)

(module
  ;; Same as above, but now we should see references to $A.desc and $B.desc
  ;; optimized to nullref because they are not instantiated. Similarly, $A is
  ;; optimized to $B with TNH.
  (rec
    ;; YESTNH:      (rec
    ;; YESTNH-NEXT:  (type $A (sub (descriptor $A.desc (struct (field (ref null $B)) (field (ref null $B))))))
    ;; NO_TNH:      (rec
    ;; NO_TNH-NEXT:  (type $A (sub (descriptor $A.desc (struct (field (ref null $A)) (field (ref null $B))))))
    (type $A (sub (descriptor $A.desc (struct (field (ref null $A) (ref null $B))))))
    ;; YESTNH:       (type $A.desc (sub (describes $A (struct (field nullref) (field nullref)))))
    ;; NO_TNH:       (type $A.desc (sub (describes $A (struct (field nullref) (field nullref)))))
    (type $A.desc (sub (describes $A (struct (field (ref null $A.desc) (ref null $B.desc))))))
    ;; YESTNH:       (type $B (sub $A (descriptor $B.desc (struct (field (ref null $B)) (field (ref null $B))))))
    ;; NO_TNH:       (type $B (sub $A (descriptor $B.desc (struct (field (ref null $A)) (field (ref null $B))))))
    (type $B (sub $A (descriptor $B.desc (struct (field (ref null $A) (ref null $B))))))
    ;; YESTNH:       (type $B.desc (sub $A.desc (describes $B (struct (field nullref) (field nullref)))))
    ;; NO_TNH:       (type $B.desc (sub $A.desc (describes $B (struct (field nullref) (field nullref)))))
    (type $B.desc (sub $A.desc (describes $B (struct (field (ref null $A.desc) (ref null $B.desc))))))
  )

  ;; YESTNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; YESTNH-NEXT:  (ref.null none)
  ;; YESTNH-NEXT: ))
  ;; NO_TNH:      (global $g (ref (exact $B)) (struct.new_default $B
  ;; NO_TNH-NEXT:  (ref.null none)
  ;; NO_TNH-NEXT: ))
  (global $g (ref (exact $B))
    (struct.new_default $B
      (ref.null none)
    )
  )
)
