;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; Compare the normal type refining pass to the GUFA variant.

;; RUN: foreach %s %t wasm-opt -all --closed-world --preserve-type-order \
;; RUN:     --type-refining-gufa      -S -o - | fileNRML %s --NRML-prefix=NRML
;; RUN: foreach %s %t wasm-opt -all --closed-world --preserve-type-order \
;; RUN:     --type-refining-gufa -S -o - | fileNRML %s --NRML-prefix=GUFA

;; A module that requires GUFA to fully optimize, as we must track type
;; information through locals etc. We will do nothing for $A, but $B's field can
;; be fully refined to (ref $B) despite the challenges in the code below, but
;; only with GUFA.
(module
  (rec
    (type $A (sub (struct (field (mut anyref)))))
    (type $B (sub (struct (field (mut anyref)))))
  )

  (func $work (param $struct (ref $struct))
    (local $a anyref)
    (local $b (ref null $B))
    ;; $A's field contains null.
    (local.set $a
      (struct.new_default $A)
    )
    ;; $B's field contains a reference to $A, even though the local's type is
    ;; anyref.
    (local.set $b
      (struct.new $B
        (local.get $a)
      )
    )
    ;; Another write to $B's field, of $b, which is a nullable $B, but we can
    ;; tell it is non-nullable.
    (local.set $b
      (struct.new $B
        (local.get $b)
      )
    )
    ;; Another write to $B's field, reading from it, which forms a cycle. This
    ;; does not prevent us from optimizing.
    (local.set $b
      (struct.new $B
        (struct.get $B 0
          (local.get $b)
        )
      )
    )
  )
)
