;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --generate-stack-ir --optimize-stack-ir --roundtrip -S -o - | filecheck %s
;; RUN: wasm-opt %s -all --generate-stack-ir --optimize-stack-ir --roundtrip --nominal -S -o - | filecheck %s --check-prefix NOMNL

(module
 (type ${i32} (struct (field i32)))
 ;; CHECK:      (export "export" (func $test))
 ;; NOMNL:      (export "export" (func $test))
 (export "export" (func $test))
 ;; CHECK:      (func $test
 ;; CHECK-NEXT:  (call $help
 ;; CHECK-NEXT:   (struct.new_default $\7bi32\7d)
 ;; CHECK-NEXT:   (block $label$1 (result i32)
 ;; CHECK-NEXT:    (nop)
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $test (type $none_=>_none)
 ;; NOMNL-NEXT:  (call $help
 ;; NOMNL-NEXT:   (struct.new_default $\7bi32\7d)
 ;; NOMNL-NEXT:   (block $label$1 (result i32)
 ;; NOMNL-NEXT:    (nop)
 ;; NOMNL-NEXT:    (i32.const 1)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT: )
 (func $test
  (call $help
   (struct.new_default ${i32})
   ;; Stack IR optimizations can remove this block, leaving a nop in an odd
   ;; "stacky" location. On load, we would normally use a local to work around
   ;; that, creating a block to contain the non-nullable reference before us and
   ;; the nop, and then returning the local. But we can't use a local for a
   ;; non-nullable reference, so we should not optimize this sort of thing in
   ;; stack IR.
   ;; TODO: This shouldn't be true after #4824 is resolved.
   (block $block (result i32)
    (nop)
    (i32.const 1)
   )
  )
 )
 ;; CHECK:      (func $help (param $3 (ref $\7bi32\7d)) (param $4 i32)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $help (type $ref|$\7bi32\7d|_i32_=>_none) (param $3 (ref $\7bi32\7d)) (param $4 i32)
 ;; NOMNL-NEXT:  (nop)
 ;; NOMNL-NEXT: )
 (func $help (param $3 (ref ${i32})) (param $4 i32)
  (nop)
 )
)
