;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --nominal --signature-refining -all -S -o - | filecheck %s

;; One function is dropped, while the the other is used. We can remove the
;; result from the dropped one.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $sig1 (func_subtype func))
  (type $sig1 (func_subtype (result anyref) func))

  ;; CHECK:      (type $sig2 (func_subtype (result (ref $struct)) func))
  (type $sig2 (func_subtype (result anyref) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $dropped (type $sig1)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct))
  ;; CHECK-NEXT:    (if
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:     (block
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.new $struct
  ;; CHECK-NEXT:        (i32.const 1)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (return)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped (type $sig1) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $used (type $sig2) (result (ref $struct))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (return
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $used (type $sig2) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $caller (type $none_=>_none)
  ;; CHECK-NEXT:  (local $temp anyref)
  ;; CHECK-NEXT:  (call $dropped)
  ;; CHECK-NEXT:  (local.set $temp
  ;; CHECK-NEXT:   (call $used)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller
    (local $temp anyref)
    (drop
      (call $dropped)
    )
    (local.set $temp
      (call $used)
    )
  )
)

;; As before, but now the signature is shared. We cannot optimize them both, so
;; we do not optimize.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $sig (func_subtype (result (ref $struct)) func))
  (type $sig (func_subtype (result anyref) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $dropped (type $sig) (result (ref $struct))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (return
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped (type $sig) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $used (type $sig) (result (ref $struct))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (return
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $used (type $sig) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $caller (type $none_=>_none)
  ;; CHECK-NEXT:  (local $temp anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $dropped)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $temp
  ;; CHECK-NEXT:   (call $used)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller
    (local $temp anyref)
    (drop
      (call $dropped)
    )
    (local.set $temp
      (call $used)
    )
  )
)

;; As before with a shared signature, but now both are dropped, so we optimize
;; both.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $sig (func_subtype func))
  (type $sig (func_subtype (result anyref) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $dropped (type $sig)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct))
  ;; CHECK-NEXT:    (if
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:     (block
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.new $struct
  ;; CHECK-NEXT:        (i32.const 1)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (return)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped (type $sig) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $dropped2 (type $sig)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $struct))
  ;; CHECK-NEXT:    (if
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:     (block
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.new $struct
  ;; CHECK-NEXT:        (i32.const 1)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (return)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped2 (type $sig) (result anyref)
    (if
      (i32.const 1)
      (return
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $caller (type $none_=>_none)
  ;; CHECK-NEXT:  (call $dropped)
  ;; CHECK-NEXT:  (call $dropped2)
  ;; CHECK-NEXT: )
  (func $caller
    (drop
      (call $dropped)
    )
    (drop
      (call $dropped2)
    )
  )
)

;; We don't change the type of a function that contains a return_call (since the
;; return type has another constraint on it).
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $sig (func_subtype (result anyref) func))
  (type $sig (func_subtype (result anyref) func))

  ;; CHECK:      (type $ref|$struct|_=>_anyref (func_subtype (param (ref $struct)) (result anyref) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $dropped (type $sig) (result anyref)
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (return_call $other
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped (type $sig) (result anyref)
    (if
      (i32.const 1)
      (return_call $other
        (struct.new $struct
          (i32.const 1)
        )
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $other (type $ref|$struct|_=>_anyref) (param $0 (ref $struct)) (result anyref)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $other (param anyref) (result anyref)
    (unreachable)
  )

  ;; CHECK:      (func $caller (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $dropped)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller
    (drop
      (call $dropped)
    )
  )
)

;; We don't change the type of a function that is return_call'ed (since the
;; return type has another constraint on it).
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $sig (func_subtype (result anyref) func))
  (type $sig (func_subtype (result anyref) func))

  ;; CHECK:      (type $anyref_=>_anyref (func_subtype (param anyref) (result anyref) func))

  ;; CHECK:      (func $dropped (type $sig) (result anyref)
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $dropped (type $sig) (result anyref)
    (struct.new $struct
      (i32.const 2)
    )
  )

  ;; CHECK:      (func $caller (type $sig) (result anyref)
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (return_call $dropped)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (result anyref)
    (if
      (i32.const 1)
      (drop
        (return_call $dropped)
      )
    )
    (struct.new $struct
      (i32.const 2)
    )
  )
)
