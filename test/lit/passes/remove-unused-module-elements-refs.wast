;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --remove-unused-module-elements --nominal -all -S -o - | filecheck %s

(module
  ;; CHECK:      (type $A (func_subtype func))
  (type $A (func))
  ;; CHECK:      (type $B (func_subtype func))
  (type $B (func))

  ;; CHECK:      (elem declare func $target-A $target-B)

  ;; CHECK:      (export "foo" (func $foo))

  ;; CHECK:      (func $foo (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (block
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (export "foo")
    ;; This export has two RefFuncs, and one CallRef.
    (drop
      (ref.func $target-A)
    )
    (drop
      (ref.func $target-B)
    )
    (call_ref
      (ref.null $A)
    )
    ;; Verify that we do not crash on an unreachable call_ref, which has no
    ;; heap type for us to analyze.
    (call_ref
      (unreachable)
    )
  )

  ;; CHECK:      (func $target-A (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A (type $A)
    ;; This function is reachable from the export "foo": there is a RefFunc and
    ;; a CallRef for it there.
  )

  (func $target-A-noref (type $A)
    ;; This function is not reachable. We have a CallRef of the right type, but
    ;; no RefFunc.
  )

  ;; CHECK:      (func $target-B (type $B)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $target-B (type $B)
    ;; This function is not reachable. We have a RefFunc in "foo" but no
    ;; suitable CallRef.
    ;;
    ;; Note that we cannot remove the function, as the RefFunc must refer to
    ;; something in order to validate. But we can clear out the body of this
    ;; function with an unreachable.
  )
)

;; As above, but reverse the order inside $foo, so we see the CallRef first.
(module
  ;; CHECK:      (type $A (func_subtype func))
  (type $A (func))
  (type $B (func))

  ;; CHECK:      (elem declare func $target-A)

  ;; CHECK:      (export "foo" (func $foo))

  ;; CHECK:      (func $foo (type $A)
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (export "foo")
    (call_ref
      (ref.null $A)
    )
    (drop
      (ref.func $target-A)
    )
  )

  ;; CHECK:      (func $target-A (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A (type $A)
    ;; This function is reachable.
  )

  (func $target-A-noref (type $A)
    ;; This function is not reachable.
  )
)

;; As above, but interleave CallRefs with RefFuncs.
(module
  ;; CHECK:      (type $A (func_subtype func))
  (type $A (func))
  (type $B (func))

  ;; CHECK:      (elem declare func $target-A-1 $target-A-2)

  ;; CHECK:      (export "foo" (func $foo))

  ;; CHECK:      (func $foo (type $A)
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A-1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A-2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (export "foo")
    (call_ref
      (ref.null $A)
    )
    (drop
      (ref.func $target-A-1)
    )
    (call_ref
      (ref.null $A)
    )
    (drop
      (ref.func $target-A-2)
    )
  )

  ;; CHECK:      (func $target-A-1 (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A-1 (type $A)
    ;; This function is reachable.
  )

  ;; CHECK:      (func $target-A-2 (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A-2 (type $A)
    ;; This function is reachable.
  )

  (func $target-A-3 (type $A)
    ;; This function is not reachable.
  )
)

;; As above, with the order reversed inside $foo. The results should be the
;; same.
(module
  ;; CHECK:      (type $A (func_subtype func))
  (type $A (func))
  (type $B (func))

  ;; CHECK:      (elem declare func $target-A-1 $target-A-2)

  ;; CHECK:      (export "foo" (func $foo))

  ;; CHECK:      (func $foo (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A-1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $target-A-2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (ref.null $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (export "foo")
    (drop
      (ref.func $target-A-1)
    )
    (call_ref
      (ref.null $A)
    )
    (drop
      (ref.func $target-A-2)
    )
    (call_ref
      (ref.null $A)
    )
  )

  ;; CHECK:      (func $target-A-1 (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A-1 (type $A)
    ;; This function is reachable.
  )

  ;; CHECK:      (func $target-A-2 (type $A)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $target-A-2 (type $A)
    ;; This function is reachable.
  )

  (func $target-A-3 (type $A)
    ;; This function is not reachable.
  )
)

(module
  ;; A j2wasm-like itable pattern: An itable is an array of (possibly-null)
  ;; data that is filled with vtables of different types. On usage, we do a
  ;; cast of the vtable type.

  ;; CHECK:      (type $vtable-B (struct_subtype (field (ref $B)) data))

  ;; CHECK:      (type $A (func_subtype func))
  (type $A (func))

  ;; CHECK:      (type $object (struct_subtype (field (ref $itable)) data))

  ;; CHECK:      (type $itable (array_subtype (ref null data) data))

  ;; CHECK:      (type $B (func_subtype func))
  (type $B (func))

  (type $itable (array_subtype (ref null data) data))

  (type $object (struct_subtype (ref $itable) data))

  ;; CHECK:      (type $vtable-A (struct_subtype (field (ref $A)) data))
  (type $vtable-A (struct_subtype (ref $A) data))

  (type $vtable-B (struct_subtype (ref $B) data))

  ;; CHECK:      (global $itable (ref $itable) (array.init_static $itable
  ;; CHECK-NEXT:  (struct.new $vtable-A
  ;; CHECK-NEXT:   (ref.func $func-A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $vtable-B
  ;; CHECK-NEXT:   (ref.func $func-B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: ))
  (global $itable (ref $itable)
    (array.init_static $itable
      (struct.new $vtable-A
        (ref.func $func-A)
      )
      (struct.new $vtable-B
        (ref.func $func-B)
      )
    )
  )

  ;; CHECK:      (export "use-itable" (func $use-itable))

  ;; CHECK:      (func $use-itable (type $A)
  ;; CHECK-NEXT:  (local $ref (ref null $object))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $object
  ;; CHECK-NEXT:    (global.get $itable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (struct.get $vtable-B 0
  ;; CHECK-NEXT:    (ref.cast_static $vtable-B
  ;; CHECK-NEXT:     (array.get $itable
  ;; CHECK-NEXT:      (struct.get $object 0
  ;; CHECK-NEXT:       (local.get $ref)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (i32.const 1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $use-itable (export "use-itable")
    (local $ref (ref null $object))
    ;; This is enough to use all the elements in the itable, which means we need
    ;; to keep references to $func-A/B around.
    (local.set $ref
      (struct.new $object
        (global.get $itable)
      )
    )
    ;; Also call one of them, $vtable-B, but not the other. $A can be emptied
    ;; out with an unreachable.
    (call_ref
      (struct.get $vtable-B 0
        (ref.cast_static $vtable-B
          (array.get $itable
            (struct.get $object 0
              (local.get $ref)
            )
            (i32.const 1)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $func-A (type $A)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $func-A (type $A)
    (nop)
  )

  ;; CHECK:      (func $func-B (type $B)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $func-B (type $B)
    (nop)
  )
)
