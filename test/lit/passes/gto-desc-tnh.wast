;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt      -all --closed-world --gto --preserve-type-order -S -o - | filecheck %s
;; RUN: foreach %s %t wasm-opt -tnh -all --closed-world --gto --preserve-type-order -S -o - | filecheck %s --check-prefix=T_N_H

;; The descriptor passed in is nullable, so it might trap. We only remove it
;; when traps never happen.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (struct))
    (type $A (descriptor $B (struct)))
    ;; CHECK:       (type $B (struct))
    (type $B (describes $A (struct)))
  )

  ;; CHECK:       (type $2 (func))

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $A (ref $A))
  ;; CHECK-NEXT:  (local $B (ref $B))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test (param $nullable (ref null $B))
    (local $A (ref $A))
    (local $B (ref $B))
    (drop
      (struct.new $A
        (local.get $nullable)
      )
    )
  )
)

;; As above, with the struct.new in the global scope.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (struct))
    (type $A (descriptor $B (struct)))
    ;; CHECK:       (type $B (struct))
    (type $B (describes $A (struct)))
  )

  ;; CHECK:       (type $2 (func))

  (global $g anyref (struct.new $A
    (struct.new $B)
  ))

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $A (ref $A))
  ;; CHECK-NEXT:  (local $B (ref $B))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test (param $nullable (ref null $B))
    (local $A (ref $A))
    (local $B (ref $B))
  )
)

