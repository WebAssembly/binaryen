;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --dae -S -o - | filecheck %s
;; RUN: wasm-opt %s -all --dae --nominal -S -o - | filecheck %s --check-prefix=NOMNL

(module
 ;; CHECK:      (type ${} (struct ))
 ;; NOMNL:      (type ${} (struct_subtype  data))
 (type ${} (struct))

 ;; CHECK:      (func $foo
 ;; CHECK-NEXT:  (call $bar)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $foo (type $none_=>_none)
 ;; NOMNL-NEXT:  (call $bar)
 ;; NOMNL-NEXT: )
 (func $foo
  (call $bar
   (i31.new
    (i32.const 1)
   )
  )
 )
 ;; CHECK:      (func $bar
 ;; CHECK-NEXT:  (local $0 (ref null i31))
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (ref.as_non_null
 ;; CHECK-NEXT:    (local.tee $0
 ;; CHECK-NEXT:     (i31.new
 ;; CHECK-NEXT:      (i32.const 2)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (local.tee $0
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $bar (type $none_=>_none)
 ;; NOMNL-NEXT:  (local $0 (ref null i31))
 ;; NOMNL-NEXT:  (drop
 ;; NOMNL-NEXT:   (ref.as_non_null
 ;; NOMNL-NEXT:    (local.tee $0
 ;; NOMNL-NEXT:     (i31.new
 ;; NOMNL-NEXT:      (i32.const 2)
 ;; NOMNL-NEXT:     )
 ;; NOMNL-NEXT:    )
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (local.tee $0
 ;; NOMNL-NEXT:   (unreachable)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT: )
 (func $bar (param $0 i31ref)
  (drop
   ;; after the parameter is removed, we create a nullable local to replace it,
   ;; and must update the tee's type accordingly to avoid a validation error,
   ;; and also add a ref.as_non_null so that the outside still receives the
   ;; same type as before
   (local.tee $0
    (i31.new
     (i32.const 2)
    )
   )
  )
  ;; test for an unreachable tee, whose type must be unreachable even after
  ;; the change (the tee would need to be dropped if it were not unreachable,
  ;; so the correctness in this case is visible in the output)
  (local.tee $0
   (unreachable)
  )
 )
 ;; a function that gets an rtt that is never used. we cannot create a local for
 ;; that parameter, as it is not defaultable, so do not remove the parameter.
 ;; CHECK:      (func $get-rtt (param $0 (rtt ${}))
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $get-rtt (type $rtt_${}_=>_none) (param $0 (rtt ${}))
 ;; NOMNL-NEXT:  (nop)
 ;; NOMNL-NEXT: )
 (func $get-rtt (param $0 (rtt ${}))
  (nop)
 )
 ;; CHECK:      (func $send-rtt
 ;; CHECK-NEXT:  (call $get-rtt
 ;; CHECK-NEXT:   (rtt.canon ${})
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $send-rtt (type $none_=>_none)
 ;; NOMNL-NEXT:  (call $get-rtt
 ;; NOMNL-NEXT:   (rtt.canon ${})
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT: )
 (func $send-rtt
  (call $get-rtt
   (rtt.canon ${})
  )
 )

 ;; CHECK:      (func $unused-and-refinable
 ;; CHECK-NEXT:  (local $0 (ref null data))
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $unused-and-refinable (type $none_=>_none)
 ;; NOMNL-NEXT:  (local $0 (ref null data))
 ;; NOMNL-NEXT:  (nop)
 ;; NOMNL-NEXT: )
 (func $unused-and-refinable (param $0 dataref)
  ;; This function does not use $0. It is called with ${}, so it is also
  ;; a parameter whose type we can refine. Do not do both operations: instead,
  ;; just remove it because it is ignored, without altering the type (handling
  ;; both operations would introduce some corner cases, and it just isn't worth
  ;; handling them if the param is completely unused anyhow). We should see in
  ;; the test output that the local $0 (the unused param is turned into a local)
  ;; we remain with type data, only modified to be nullable, and we are not
  ;; refined to ${} which is how we are called.
 )

 ;; CHECK:      (func $call-unused-and-refinable
 ;; CHECK-NEXT:  (call $unused-and-refinable)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $call-unused-and-refinable (type $none_=>_none)
 ;; NOMNL-NEXT:  (call $unused-and-refinable)
 ;; NOMNL-NEXT: )
 (func $call-unused-and-refinable
  (call $unused-and-refinable
   (struct.new_default ${})
  )
 )

 ;; CHECK:      (func $non-nullable-fixup (param $0 (ref ${}))
 ;; CHECK-NEXT:  (local $1 (ref null data))
 ;; CHECK-NEXT:  (local.set $1
 ;; CHECK-NEXT:   (local.get $0)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (local.set $1
 ;; CHECK-NEXT:   (ref.as_non_null
 ;; CHECK-NEXT:    (local.get $1)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $non-nullable-fixup (type $ref|${}|_=>_none) (param $0 (ref ${}))
 ;; NOMNL-NEXT:  (local $1 (ref null data))
 ;; NOMNL-NEXT:  (local.set $1
 ;; NOMNL-NEXT:   (local.get $0)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (local.set $1
 ;; NOMNL-NEXT:   (ref.as_non_null
 ;; NOMNL-NEXT:    (local.get $1)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT: )
 (func $non-nullable-fixup (param $0 dataref)
  ;; Use the param to avoid other opts removing it, and to force us to do a
  ;; fixup when we refine the param's type. When doing so, we must handle the
  ;; fact that the new local's type is non-nullable.
  (local.set $0
   (local.get $0)
  )
 )

 ;; CHECK:      (func $call-non-nullable-fixup
 ;; CHECK-NEXT:  (call $non-nullable-fixup
 ;; CHECK-NEXT:   (struct.new_default ${})
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $call-non-nullable-fixup (type $none_=>_none)
 ;; NOMNL-NEXT:  (call $non-nullable-fixup
 ;; NOMNL-NEXT:   (struct.new_default ${})
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT: )
 (func $call-non-nullable-fixup
  (call $non-nullable-fixup
   (struct.new_default ${})
  )
 )
)
