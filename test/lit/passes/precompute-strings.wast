;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: wasm-opt %s --precompute-propagate -all -S -o - | filecheck %s

(module
 ;; CHECK:      (type $0 (func (result i32)))

 ;; CHECK:      (type $array16 (array (mut i16)))
 (type $array16 (array (mut i16)))

 ;; CHECK:      (type $2 (func (result (ref string))))

 ;; CHECK:      (type $3 (func (result (ref any))))

 ;; CHECK:      (export "get_codepoint-bad" (func $get_codepoint-bad))

 ;; CHECK:      (export "test" (func $encode-stashed))

 ;; CHECK:      (export "slice" (func $slice))

 ;; CHECK:      (export "slice-bad" (func $slice-bad))

 ;; CHECK:      (func $eq-no (type $0) (result i32)
 ;; CHECK-NEXT:  (i32.const 0)
 ;; CHECK-NEXT: )
 (func $eq-no (result i32)
  (string.eq
   (string.const "ab")
   (string.const "cdefg")
  )
 )

 ;; CHECK:      (func $eq-yes (type $0) (result i32)
 ;; CHECK-NEXT:  (i32.const 1)
 ;; CHECK-NEXT: )
 (func $eq-yes (result i32)
  (string.eq
   (string.const "ab")
   (string.const "ab")
  )
 )

 ;; CHECK:      (func $concat (type $0) (result i32)
 ;; CHECK-NEXT:  (i32.const 1)
 ;; CHECK-NEXT: )
 (func $concat (result i32)
  (string.eq
   (string.concat (string.const "a") (string.const "b"))
   (string.const "ab")
  )
 )

 ;; CHECK:      (func $concat-bad (type $0) (result i32)
 ;; CHECK-NEXT:  (string.eq
 ;; CHECK-NEXT:   (string.concat
 ;; CHECK-NEXT:    (string.const "a\f0")
 ;; CHECK-NEXT:    (string.const "b")
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (string.const "a\f0b")
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $concat-bad (result i32)
  (string.eq
   (string.concat (string.const "a\F0") (string.const "b"))
   (string.const "a\F0b")
  )
 )

 ;; CHECK:      (func $length (type $0) (result i32)
 ;; CHECK-NEXT:  (i32.const 7)
 ;; CHECK-NEXT: )
 (func $length (result i32)
  (stringview_wtf16.length
   (string.as_wtf16
    (string.const "1234567")
   )
  )
 )

 ;; CHECK:      (func $length-bad (type $0) (result i32)
 ;; CHECK-NEXT:  (stringview_wtf16.length
 ;; CHECK-NEXT:   (string.as_wtf16
 ;; CHECK-NEXT:    (string.const "$_\c2\a3_\e2\82\ac_\f0\90\8d\88")
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $length-bad (result i32)
  ;; Not precomputable because we don't handle unicode yet.
  (stringview_wtf16.length
   (string.as_wtf16
    ;; $_¬£_‚Ç¨_êçà
    (string.const "$_\C2\A3_\E2\82\AC_\F0\90\8D\88")
   )
  )
 )

 ;; CHECK:      (func $get_codepoint (type $0) (result i32)
 ;; CHECK-NEXT:  (i32.const 95)
 ;; CHECK-NEXT: )
 (func $get_codepoint (result i32)
  ;; This is computable because everything up to the requested index is ascii. Returns 95 ('_').
  (stringview_wtf16.get_codeunit
   (string.as_wtf16
    ;; $_¬£_‚Ç¨_êçà
    (string.const "$_\C2\A3_\E2\82\AC_\F0\90\8D\88")
   )
   (i32.const 1)
  )
 )

 ;; CHECK:      (func $get_codepoint-bad (type $0) (result i32)
 ;; CHECK-NEXT:  (stringview_wtf16.get_codeunit
 ;; CHECK-NEXT:   (string.as_wtf16
 ;; CHECK-NEXT:    (string.const "$_\c2\a3_\e2\82\ac_\f0\90\8d\88")
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (i32.const 2)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $get_codepoint-bad (export "get_codepoint-bad") (result i32)
  ;; This is not computable because the requested code unit is not ascii.
  (stringview_wtf16.get_codeunit
   (string.as_wtf16
    ;; $_¬£_‚Ç¨_êçà
    (string.const "$_\C2\A3_\E2\82\AC_\F0\90\8D\88")
   )
   (i32.const 2)
  )
 )

 ;; CHECK:      (func $encode (type $0) (result i32)
 ;; CHECK-NEXT:  (string.encode_wtf16_array
 ;; CHECK-NEXT:   (string.const "$_")
 ;; CHECK-NEXT:   (array.new_default $array16
 ;; CHECK-NEXT:    (i32.const 20)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (i32.const 0)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $encode (result i32)
  ;; We could optimize away the encode operation here as the reference does not
  ;; escape, but we do not do escape analysis here.
  (string.encode_wtf16_array
   (string.const "$_")
   (array.new_default $array16
    (i32.const 20)
   )
   (i32.const 0)
  )
 )

 ;; CHECK:      (func $encode-bad (type $0) (result i32)
 ;; CHECK-NEXT:  (string.encode_wtf16_array
 ;; CHECK-NEXT:   (string.const "$_\c2\a3_\e2\82\ac_\f0\90\8d\88")
 ;; CHECK-NEXT:   (array.new_default $array16
 ;; CHECK-NEXT:    (i32.const 20)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (i32.const 0)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $encode-bad (result i32)
  (string.encode_wtf16_array
   ;; $_¬£_‚Ç¨_êçà
   (string.const "$_\C2\A3_\E2\82\AC_\F0\90\8D\88")
   (array.new_default $array16
    (i32.const 20)
   )
   (i32.const 0)
  )
 )

 ;; CHECK:      (func $encode-stashed (type $3) (result (ref any))
 ;; CHECK-NEXT:  (local $1 (ref $array16))
 ;; CHECK-NEXT:  (local.set $1
 ;; CHECK-NEXT:   (array.new_default $array16
 ;; CHECK-NEXT:    (i32.const 10)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (string.encode_wtf16_array
 ;; CHECK-NEXT:    (string.const "0123456789")
 ;; CHECK-NEXT:    (local.get $1)
 ;; CHECK-NEXT:    (i32.const 0)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (local.get $1)
 ;; CHECK-NEXT: )
 (func $encode-stashed (export "test") (result (ref any))
  (local $1 (ref $array16))
  ;; Create a zero-filled array.
  (local.set $1
   (array.new_default $array16
    (i32.const 10)
   )
  )
  ;; Fill it with some string data.
  (drop
   (string.encode_wtf16_array
    (string.const "0123456789")
    (local.get $1)
    (i32.const 0)
   )
  )
  ;; Return the modified array. We must not have removed the encode operation
  ;; above us (it has the side effect of modifying the array, just like an
  ;; array.copy does).
  (local.get $1)
 )

 ;; CHECK:      (func $slice (type $2) (result (ref string))
 ;; CHECK-NEXT:  (string.const "def")
 ;; CHECK-NEXT: )
 (func $slice (export "slice") (result (ref string))
  ;; Slicing [3:6] here should definitely output "def".
  (stringview_wtf16.slice
   (string.as_wtf16
    (string.const "abcdefgh")
   )
   (i32.const 3)
   (i32.const 6)
  )
 )

 ;; CHECK:      (func $slice-bad (type $2) (result (ref string))
 ;; CHECK-NEXT:  (stringview_wtf16.slice
 ;; CHECK-NEXT:   (string.as_wtf16
 ;; CHECK-NEXT:    (string.const "abcd\c2\a3fgh")
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (i32.const 3)
 ;; CHECK-NEXT:   (i32.const 6)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $slice-bad (export "slice-bad") (result (ref string))
  ;; This slice contains non-ascii, so we do not optimize.
  (stringview_wtf16.slice
   ;; abcd¬£fgh
   (string.as_wtf16
    (string.const "abcd\C2\A3fgh")
   )
   (i32.const 3)
   (i32.const 6)
  )
 )
)
