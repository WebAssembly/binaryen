;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --optimize-call-casts -S -o - | filecheck %s

(module
  ;; CHECK:      (type $funcref_ref|func|_=>_none (func (param funcref (ref func))))

  ;; CHECK:      (type $funcref_ref|func|_funcref_funcref_funcref_=>_none (func (param funcref (ref func) funcref funcref funcref)))

  ;; CHECK:      (type $ref|func|_ref|func|_ref|func|_funcref_funcref_=>_none (func (param (ref func) (ref func) (ref func) funcref funcref)))

  ;; CHECK:      (func $called (type $funcref_ref|func|_funcref_funcref_funcref_=>_none) (param $opt funcref) (param $already (ref func)) (param $also funcref) (param $no-cast funcref) (param $late-cast funcref)
  ;; CHECK-NEXT:  (call $called_4
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $opt)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $already)
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $also)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $no-cast)
  ;; CHECK-NEXT:   (local.get $late-cast)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $called
    (param $opt funcref)        ;; optimizable
    (param $already (ref func)) ;; already refined
    (param $also funcref)       ;; also optimizable
    (param $no-cast funcref)    ;; no cast at all
    (param $late-cast funcref)  ;; cast is not in entry

    ;; The first and middle parameter will be optimized. This function will
    ;; turn into a call of a new, refined function, and add casts on the
    ;; optimized params while doing so.

    (drop
      (ref.cast func
        (local.get $opt)
      )
    )
    (drop
      (ref.cast func
        (local.get $already)
      )
    )
    (drop
      (ref.cast func
        (local.get $also)
      )
    )
    (drop
      (local.get $no-cast)
    )
    (if
      (i32.const 0)
      (return)
    )
    (drop
      (ref.cast func
        (local.get $late-cast)
      )
    )
  )

  ;; CHECK:      (func $caller (type $funcref_ref|func|_=>_none) (param $x funcref) (param $y (ref func))
  ;; CHECK-NEXT:  (call $called_4
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (param $x funcref) (param $y (ref func))
    ;; This will turn into a call of a new, refined function, and have casts on
    ;; the first and middle parameter.
    (call $called
      (local.get $x)
      (local.get $y)
      (local.get $x)
      (local.get $x)
      (local.get $x)
    )
  )

  ;; CHECK:      (func $caller-2 (type $funcref_ref|func|_=>_none) (param $x funcref) (param $y (ref func))
  ;; CHECK-NEXT:  (call $called_4
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (block (result funcref)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (i32.const 10)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (local.get $x)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (block (result (ref func))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $y)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller-2 (param $x funcref) (param $y (ref func))
    ;; Another call, which will be treated the same even though it has some
    ;; nested stuff on some parameters.
    (call $called
      (block (result funcref)
        (drop
          (i32.const 10)
        )
        (local.get $x)
      )
      (block (result (ref func))
        (drop
          (i32.const 20)
        )
        (local.get $y)
      )
      (local.get $x)
      (local.get $x)
      (local.get $x)
    )
  )

  ;; CHECK:      (func $caller-3 (type $funcref_ref|func|_=>_none) (param $x funcref) (param $y (ref func))
  ;; CHECK-NEXT:  (local $2 funcref)
  ;; CHECK-NEXT:  (local $3 (ref func))
  ;; CHECK-NEXT:  (local $4 funcref)
  ;; CHECK-NEXT:  (local $5 funcref)
  ;; CHECK-NEXT:  (local $6 funcref)
  ;; CHECK-NEXT:  (local.set $2
  ;; CHECK-NEXT:   (block (result funcref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $3
  ;; CHECK-NEXT:   (block (result (ref func))
  ;; CHECK-NEXT:    (if
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:     (return)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $y)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $4
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $5
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $6
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $called_4
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $3)
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $4)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $5)
  ;; CHECK-NEXT:   (local.get $6)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller-3 (param $x funcref) (param $y (ref func))
    ;; Another call, as the above, but now there is a possible transfer of
    ;; control flow in some of the nested stuff. This makes us use locals to
    ;; avoid the risk of casting if the call is not actually taken - we can only
    ;; cast right before the call is definitely happening.
    (call $called
      (block (result funcref)
        (drop
          (i32.const 30)
        )
        (local.get $x)
      )
      (block (result (ref func))
        (if
          (i32.const 0)
          (return)
        )
        (local.get $y)
      )
      (local.get $x)
      (local.get $x)
      (local.get $x)
    )
  )
)

;; CHECK:      (func $called_4 (type $ref|func|_ref|func|_ref|func|_funcref_funcref_=>_none) (param $opt (ref func)) (param $already (ref func)) (param $also (ref func)) (param $no-cast funcref) (param $late-cast funcref)
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (local.get $opt)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (local.get $already)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (local.get $also)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (local.get $no-cast)
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (if
;; CHECK-NEXT:   (i32.const 0)
;; CHECK-NEXT:   (return)
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (local.get $late-cast)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
(module
  ;; CHECK:      (type $A (struct ))
  (type $A (struct))

  ;; CHECK:      (type $anyref_=>_none (func (param anyref)))

  ;; CHECK:      (type $ref?|$A|_=>_none (func (param (ref null $A))))

  ;; CHECK:      (func $two-casts (type $anyref_=>_none) (param $x anyref)
  ;; CHECK-NEXT:  (call $two-casts_3
  ;; CHECK-NEXT:   (ref.cast null $A
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $two-casts (param $x (ref null any))
    ;; Two casts appear here. We will simply apply the first of the two (even
    ;; though it is less refined; in an optimized build, other passes would have
    ;; left only the more refined one anyhow, so we don't try hard).
    (drop
      (ref.cast null $A
        (local.get $x)
      )
    )
    (drop
      (ref.cast $A
        (local.get $x)
      )
    )
  )

  ;; CHECK:      (func $caller (type $anyref_=>_none) (param $x anyref)
  ;; CHECK-NEXT:  (call $two-casts_3
  ;; CHECK-NEXT:   (ref.cast null $A
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (param $x anyref)
    (call $two-casts
      (local.get $x)
    )
  )

  ;; CHECK:      (func $caller-caller (type $anyref_=>_none) (param $x anyref)
  ;; CHECK-NEXT:  (call $caller
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller-caller (param $x anyref)
    ;; Calls a function where we have no params to optimize whatsoever. Nothing
    ;; should change here.
    (call $caller
      (local.get $x)
    )
  )
)

;; CHECK:      (func $two-casts_3 (type $ref?|$A|_=>_none) (param $x (ref null $A))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.cast null $A
;; CHECK-NEXT:    (local.get $x)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.cast $A
;; CHECK-NEXT:    (local.get $x)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
(module
  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (type $ref|func|_=>_none (func (param (ref func))))

  ;; CHECK:      (func $recursion (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call $recursion_1
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $recursion (param $x funcref)
    ;; Cast the parameter, allowing us to optimize.
    (drop
      (ref.cast func
        (local.get $x)
      )
    )
    ;; Call the function from within itself, to test recursion. This call will
    ;; be optimized into a call to a refined version of the function. That
    ;; function's call should be optimized as well, to call itself.
    (call $recursion
      (block (result funcref)
        (local.get $x)
      )
    )
  )
)
;; CHECK:      (func $recursion_1 (type $ref|func|_=>_none) (param $x (ref func))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (local.get $x)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (call $recursion_1
;; CHECK-NEXT:   (ref.as_func
;; CHECK-NEXT:    (block (result (ref func))
;; CHECK-NEXT:     (local.get $x)
;; CHECK-NEXT:    )
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
