;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt -all --gufa -S -o - | filecheck %s

(module
  ;; CHECK:      (type $0 (func (param i32)))

  ;; CHECK:      (type $1 (func (result i32)))

  ;; CHECK:      (type $2 (func))

  ;; CHECK:      (tag $e (param i32))
  (tag $e (param i32))

  ;; CHECK:      (func $try_table-target-block-is-not-unreachable (type $1) (result i32)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block $catch (result i32)
  ;; CHECK-NEXT:    (try_table (catch $e $catch)
  ;; CHECK-NEXT:     (throw $e
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.const 0)
  ;; CHECK-NEXT: )
  (func $try_table-target-block-is-not-unreachable (result i32)
    ;; Ensure that try_table connects caught tags with their branch targets.
    (block $catch (result i32)
      (try_table (catch $e $catch)
        (throw $e (i32.const 0))
      )
    )
  )

  ;; CHECK:      (func $try_table-materializes-exnref (type $2)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block $catch (result exnref)
  ;; CHECK-NEXT:    (try_table (catch_all_ref $catch)
  ;; CHECK-NEXT:     (throw $e
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $try_table-materializes-exnref
    ;; Ensure that catch_all_ref materializes a non-null exnref value. If we do
    ;; not connect a non-null exnref value to the branch target, GUFA will think
    ;; no value can possibly get out of that block, and will insert an
    ;; unreachable instruction after the block.
    (drop
      (block $catch (result exnref)
        (try_table (catch_all_ref $catch)
          (throw $e (i32.const 0))
        )
      )
    )
  )
)
