;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.

;; Reorder types with the real cost model instead of the testing cost model to
;; make sure it still respects ordering constraints, no matter what order the
;; types are found in.

;; RUN: foreach %s %t wasm-opt -all --closed-world --reorder-types -S -o - \
;; RUN:     | filecheck %s

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $A))
  ;; CHECK-NEXT:  (local $1 (ref $B))
  ;; CHECK-NEXT:  (local $2 (ref $C))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $A))
    (local (ref $B))
    (local (ref $C))
  )
)

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $A))
  ;; CHECK-NEXT:  (local $1 (ref $C))
  ;; CHECK-NEXT:  (local $2 (ref $B))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $A))
    (local (ref $C))
    (local (ref $B))
  )
)

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $B))
  ;; CHECK-NEXT:  (local $1 (ref $A))
  ;; CHECK-NEXT:  (local $2 (ref $C))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $B))
    (local (ref $A))
    (local (ref $C))
  )
)

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $B))
  ;; CHECK-NEXT:  (local $1 (ref $C))
  ;; CHECK-NEXT:  (local $2 (ref $A))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $B))
    (local (ref $C))
    (local (ref $A))
  )
)

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $C))
  ;; CHECK-NEXT:  (local $1 (ref $A))
  ;; CHECK-NEXT:  (local $2 (ref $B))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $C))
    (local (ref $A))
    (local (ref $B))
  )
)

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (sub (struct)))
    (type $A (sub (struct)))
    ;; CHECK:       (type $B (sub $A (struct)))
    (type $B (sub $A (struct)))
    ;; CHECK:       (type $C (sub $B (struct)))
    (type $C (sub $B (struct)))
  )

  ;; CHECK:      (func $test (type $2)
  ;; CHECK-NEXT:  (local $0 (ref $C))
  ;; CHECK-NEXT:  (local $1 (ref $B))
  ;; CHECK-NEXT:  (local $2 (ref $A))
  ;; CHECK-NEXT: )
  (func $test
    (local (ref $C))
    (local (ref $B))
    (local (ref $A))
  )
)
