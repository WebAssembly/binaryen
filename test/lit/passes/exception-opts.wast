;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --exception-opts -S -o - | filecheck %s

(module
  ;; CHECK:      (import "out" "func" (func $import))

  ;; CHECK:      (tag $e (param))
  (tag $e (param))
  ;; CHECK:      (tag $e1 (param))
  (tag $e1 (param))

  (import "out" "func" (func $import))

  ;; --------------------------------------------------------------------------
  ;; Callees that cannot throw.

  ;; CHECK:      (func $callee-nothrow0
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $callee-nothrow0)

  ;; CHECK:      (func $callee-nothrow1
  ;; CHECK-NEXT:  (try $l0
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (try $try
  ;; CHECK-NEXT:     (do
  ;; CHECK-NEXT:      (throw $e)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (delegate $l0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $callee-nothrow1
    ;; This doesn't throw, because 'throw' is eventually caught by 'catch_all'.
    (try $l0
      (do
        (try
          (do
            (throw $e)
          )
          (delegate $l0)
        )
      )
      (catch_all)
    )
  )
  ;; CHECK:      (func $callee-nothrow2
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $callee-nothrow2
    ;; This doesn't throw, because even though the 'delegate' throws to the
    ;; caller, the inner 'try' body doesn't has anything that can throw.
    (try
      (do
        (try
          (do)
          (delegate 1) ;; throws to caller
        )
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $callee-nothrow3
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $callee-nothrow3
    ;; This doesn't throw because even though the 'catch_all' body has a
    ;; 'throw', that body is not reachable because the try body doesn't throw.
    (try
      (do)
      (catch_all
        (throw $e)
      )
    )
  )

  ;; --------------------------------------------------------------------------
  ;; Callees that can throw.

  ;; CHECK:      (func $callee-throw0
  ;; CHECK-NEXT:  (throw $e)
  ;; CHECK-NEXT: )
  (func $callee-throw0
    (throw $e)
  )

  ;; CHECK:      (func $callee-throw1
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (throw $e)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e1
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $callee-throw1
    (try
      (do
        (throw $e)
      )
      (catch $e1)
    )
  )

  ;; CHECK:      (func $callee-throw2
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (try $try1
  ;; CHECK-NEXT:     (do
  ;; CHECK-NEXT:      (throw $e)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (delegate 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $callee-throw2
    ;; This throws, because the inner delegate throws to the caller.
    (try
      (do
        (try
          (do
            (throw $e)
          )
          (delegate 1) ;; throws to caller
        )
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $callee-throw3
  ;; CHECK-NEXT:  (call $import)
  ;; CHECK-NEXT: )
  (func $callee-throw3
    ;; All imported functions can throw
    (call $import)
  )

  ;; --------------------------------------------------------------------------
  ;; Caller test functions

  ;; CHECK:      (func $call-nothrow
  ;; CHECK-NEXT:  (call $callee-nothrow0)
  ;; CHECK-NEXT:  (call $callee-nothrow1)
  ;; CHECK-NEXT:  (call $callee-nothrow2)
  ;; CHECK-NEXT:  (call $callee-nothrow3)
  ;; CHECK-NEXT: )
  (func $call-nothrow
    ;; This 'try' should be removed, because none of the callees throw.
    (try
      (do
        (call $callee-nothrow0)
        (call $callee-nothrow1)
        (call $callee-nothrow2)
        (call $callee-nothrow3)
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $call-throw
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $callee-throw0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try2
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $callee-throw1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try3
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $callee-throw2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try4
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $callee-throw3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-throw
    ;; These 'try's below should NOT be removed, because all callees can throw.
    (try
      (do
        (call $callee-throw0)
      )
      (catch_all)
    )
    (try
      (do
        (call $callee-throw1)
      )
      (catch_all)
    )
    (try
      (do
        (call $callee-throw2)
      )
      (catch_all)
    )
    (try
      (do
        (call $callee-throw3)
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $call-both
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $callee-nothrow2)
  ;; CHECK-NEXT:    (call $callee-throw0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-both
    ;; This 'try' cannot be removed because the body contains a throwing call.
    (try
      (do
        (call $callee-nothrow2)
        (call $callee-throw0)
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $catch-all-inside
  ;; CHECK-NEXT:  (try $try5
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (try $try6
  ;; CHECK-NEXT:     (do
  ;; CHECK-NEXT:      (call $callee-throw0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $catch-all-inside
    ;; The outermost try can be removed, because the middle try has 'catch_all',
    ;; making it not throwable.
    (try
      (do
        (try
          (do
            (try
              (do
                (call $callee-throw0)
              )
            )
          )
          (catch_all)
        )
      )
      (catch $e)
    )
  )

  ;; CHECK:      (func $nested-try
  ;; CHECK-NEXT:  (call $callee-nothrow0)
  ;; CHECK-NEXT: )
  (func $nested-try
    ;; Now the call to $callee is embedded in a nested try, but given that
    ;; $callee doesn't throw, all nested trys can be removed.
    (try
      (do
        (try
          (do
            (try
              (do
                (try
                  (do
                    (call $callee-nothrow0)
                  )
                  (catch $e)
                )
              )
              (delegate 1)
            )
          )
        )
      )
    )
  )
)

(module
  ;; CHECK:      (tag $e (param))
  (tag $e (param))

  ;; Call graph : a -> b -> c
  ;; All trys in $b and $c can be removed.

  ;; CHECK:      (func $c
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $c)
  ;; CHECK:      (func $b
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $a)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $b
    (try
      (do
        (call $a)
      )
      (catch $e)
    )
  )
  ;; CHECK:      (func $a
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $b)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $a
    (try
      (do
        (call $b)
      )
      (catch $e)
    )
  )
)

(module
  ;; CHECK:      (tag $e (param))
  (tag $e (param))

  ;; Call graph :
  ;;   b
  ;;  / \
  ;; a   d
  ;;  \ /
  ;;   c
  ;; $a's try can be removed.

  ;; CHECK:      (func $d
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $d)

  ;; CHECK:      (func $c
  ;; CHECK-NEXT:  (call $a)
  ;; CHECK-NEXT: )
  (func $c
    (call $a)
  )
  ;; CHECK:      (func $b
  ;; CHECK-NEXT:  (call $a)
  ;; CHECK-NEXT: )
  (func $b
    (call $a)
  )

  ;; CHECK:      (func $a
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $b)
  ;; CHECK-NEXT:    (call $c)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $a
    (try
      (do
        (call $b)
        (call $c)
      )
      (catch $e)
    )
  )
)

(module
  ;; CHECK:      (tag $e (param))
  (tag $e (param))

  ;; Call graph :
  ;; a -> b -> c -> d
  ;;      ^         |
  ;;      |         |
  ;;      \---------/
  ;; $a's try cannot be removed because there is a cycle in the call graph and
  ;; curently the pass cannot handle cycles.

  ;; CHECK:      (func $d
  ;; CHECK-NEXT:  (call $b)
  ;; CHECK-NEXT: )
  (func $d
    (call $b)
  )

  ;; CHECK:      (func $c
  ;; CHECK-NEXT:  (call $d)
  ;; CHECK-NEXT: )
  (func $c
    (call $d)
  )
  ;; CHECK:      (func $b
  ;; CHECK-NEXT:  (call $c)
  ;; CHECK-NEXT: )
  (func $b
    (call $c)
  )

  ;; CHECK:      (func $a
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (call $b)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $a
    (try
      (do
        (call $b)
      )
      (catch $e)
    )
  )
)

(module
  ;; CHECK:      (tag $e (param))
  (tag $e (param))

  ;; Call graph :
  ;; a -> b -> c -> d
  ;;      ^         |
  ;;      |         |
  ;;      \---------/
  ;; Even though the call graph has a cycle, function $d's call to $b is
  ;; enclosed in a try-catch_all, making $d non-throwable. After that we can
  ;; conclude all functions here are non-throwable, so both $a's and $d's trys
  ;; can be removed.

  ;; CHECK:      (func $d
  ;; CHECK-NEXT:  (call $b)
  ;; CHECK-NEXT: )
  (func $d
    (try
      (do
        (call $b)
      )
      (catch_all)
    )
  )

  ;; CHECK:      (func $c
  ;; CHECK-NEXT:  (call $d)
  ;; CHECK-NEXT: )
  (func $c
    (call $d)
  )
  ;; CHECK:      (func $b
  ;; CHECK-NEXT:  (call $c)
  ;; CHECK-NEXT: )
  (func $b
    (call $c)
  )

  ;; CHECK:      (func $a
  ;; CHECK-NEXT:  (call $b)
  ;; CHECK-NEXT: )
  (func $a
    (try
      (do
        (call $b)
      )
      (catch $e)
    )
  )
)
