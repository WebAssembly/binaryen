;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --disable-custom-descriptors --dae -S -o - | filecheck %s

;; We cannot refine to an exact type in an export, as CD is disabled.
(module
 ;; CHECK:      (type $A (struct))

 ;; CHECK:      (type $func (sub (func (result anyref))))
 (type $func (sub (func (result anyref))))

 ;; CHECK:      (type $func2 (sub (func (result anyref i32))))
 (type $func2 (sub (func (result anyref i32))))

 (type $A (struct))

 ;; CHECK:      (func $export (type $func) (result anyref)
 ;; CHECK-NEXT:  (struct.new_default $A)
 ;; CHECK-NEXT: )
 (func $export (export "export") (type $func) (result anyref)
  ;; We can refine to (ref $A), but not an exact one.
  (struct.new $A)
 )

 ;; CHECK:      (func $export-tuple (type $func2) (result anyref i32)
 ;; CHECK-NEXT:  (tuple.make 2
 ;; CHECK-NEXT:   (struct.new_default $A)
 ;; CHECK-NEXT:   (i32.const 42)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $export-tuple (export "export-tuple") (type $func2) (result anyref i32)
  ;; Ditto, but the ref is in a tuple.
  (tuple.make 2
   (struct.new $A)
   (i32.const 42)
  )
 )
)

;; We can refine the array result to $array. However, doing so brings in the
;; entire rec group of $array, which includes an exact type, which is not
;; allowed when custom descriptors are disabled.
(module
 ;; CHECK:      (type $func (sub (func (result (ref array)))))
 (type $func (sub (func (result (ref array)))))

 (rec
  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $array (array i8))
  (type $array (array i8))
  ;; CHECK:       (type $unused (func (result (ref (exact $array)))))
  (type $unused (func (result (ref (exact $array)))))
 )

 ;; CHECK:      (func $test (type $func) (result (ref array))
 ;; CHECK-NEXT:  (array.new_fixed $array 0)
 ;; CHECK-NEXT: )
 (func $test (export "test") (type $func) (result (ref array))
  (array.new_fixed $array 0)
 )
)

