;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_passes_tests_to_lit.py and could be cleaned up.

;; RUN: foreach %s %t wasm-opt --ssa-nomerge --enable-simd -S -o - | filecheck %s

(module
  (memory 1 1)
  ;; CHECK:      (type $0 (func (param i32)))

  ;; CHECK:      (type $1 (func (param i32 i32)))

  ;; CHECK:      (type $2 (func))

  ;; CHECK:      (global $global$0 (mut i32) (i32.const 1))
  (global $global$0 (mut i32) (i32.const 1))
  ;; CHECK:      (memory $0 1 1)

  ;; CHECK:      (func $basics (param $x i32)
  ;; CHECK-NEXT:  (local $y i32)
  ;; CHECK-NEXT:  (local $z f32)
  ;; CHECK-NEXT:  (local $w i64)
  ;; CHECK-NEXT:  (local $t f64)
  ;; CHECK-NEXT:  (local $5 i32)
  ;; CHECK-NEXT:  (local $6 f64)
  ;; CHECK-NEXT:  (local $7 f64)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (f32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i64.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $5
  ;; CHECK-NEXT:   (i32.const 100)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $5)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $6
  ;; CHECK-NEXT:   (f64.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $6)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $7
  ;; CHECK-NEXT:   (f64.const 33)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $7)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $7)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $basics (param $x i32)
    (local $y i32)
    (local $z f32)
    (local $w i64)
    (local $t f64)
    (drop (local.get $x)) ;; keep as param get
    (drop (local.get $y)) ;; turn into get of 0-init
    (drop (local.get $z))
    (drop (local.get $w))
    (drop (local.get $t))
    (local.set $x (i32.const 100)) ;; overwrite param
    (drop (local.get $x)) ;; no longer a param!
    (local.set $t (f64.const 2)) ;; overwrite local
    (drop (local.get $t))
    (local.set $t (f64.const 33)) ;; overwrite local AGAIN
    (drop (local.get $t))
    (drop (local.get $t)) ;; use twice
  )
  ;; CHECK:      (func $if (param $p i32)
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local $y i32)
  ;; CHECK-NEXT:  (local $3 i32)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (if (result i32)
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:    (then
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (else
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $p
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $p)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 5)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 6)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (local.set $3
  ;; CHECK-NEXT:     (i32.const 7)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 8)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $if (param $p i32)
    (local $x i32)
    (local $y i32)
    (drop
      (if (result i32)
        (i32.const 1)
        (then
          (local.get $x)
        )
        (else
          (local.get $y)
        )
      )
    )
    (if
      (i32.const 1)
      (then
        (local.set $x (i32.const 1))
      )
    )
    (drop (local.get $x))
    ;; same but with param
    (if
      (i32.const 1)
      (then
        (local.set $p (i32.const 1))
      )
    )
    (drop (local.get $p))
    ;; if-else
    (if
      (i32.const 1)
      (then
        (local.set $x (i32.const 2))
      )
      (else
        (nop)
      )
    )
    (drop (local.get $x))
    (if
      (i32.const 1)
      (then
        (nop)
      )
      (else
        (local.set $x (i32.const 3))
      )
    )
    (drop (local.get $x))
    (if
      (i32.const 1)
      (then
        (local.set $x (i32.const 4))
      )
      (else
        (local.set $x (i32.const 5))
      )
    )
    (drop (local.get $x))
    (if
      (i32.const 1)
      (then
        (local.set $x (i32.const 6))
      )
      (else
        (block
          (local.set $x (i32.const 7))
          (local.set $x (i32.const 8))
        )
      )
    )
    (drop (local.get $x))
  )
  ;; CHECK:      (func $if2 (param $x i32)
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $x)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $if2 (param $x i32)
    (if
      (i32.const 1)
      (then
        (block
          (local.set $x (i32.const 1))
          (drop (local.get $x)) ;; use between phi set and use
        )
      )
    )
    (drop (local.get $x))
  )
  ;; CHECK:      (func $nomerge (param $p i32) (param $q i32)
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local $3 i32)
  ;; CHECK-NEXT:  (local $4 i32)
  ;; CHECK-NEXT:  (local $5 i32)
  ;; CHECK-NEXT:  (local.set $3
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $3)
  ;; CHECK-NEXT:   (local.get $3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $4
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $4)
  ;; CHECK-NEXT:   (local.get $4)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (i32.const 3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 4)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $5
  ;; CHECK-NEXT:   (i32.const 5)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $5)
  ;; CHECK-NEXT:   (local.get $5)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 6)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (local.set $x
  ;; CHECK-NEXT:     (i32.const 7)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $nomerge
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nomerge (param $p i32) (param $q i32)
    (local $x i32)
    (local.set $x (i32.const 1)) ;; untangle this
    (call $nomerge (local.get $x) (local.get $x))
    (local.set $x (i32.const 2)) ;; and this
    (call $nomerge (local.get $x) (local.get $x))
    (local.set $x (i32.const 3)) ;; but this reaches a merge later
    (call $nomerge (local.get $x) (local.get $x))
    (if (i32.const 1)
      (then
        (local.set $x (i32.const 4))
      )
    )
    (call $nomerge (local.get $x) (local.get $x))
    (local.set $x (i32.const 5)) ;; this is good again
    (call $nomerge (local.get $x) (local.get $x))
    (if (i32.const 1)
      (then
        (local.set $x (i32.const 6)) ;; these merge,
      )
      (else
        (local.set $x (i32.const 7)) ;; so no
      )
    )
    (call $nomerge (local.get $x) (local.get $x))
  )
  ;; CHECK:      (func $simd-zero
  ;; CHECK-NEXT:  (local $0 v128)
  ;; CHECK-NEXT:  (v128.store align=4
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (i32x4.splat
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $simd-zero
   (local $0 v128)
   (v128.store align=4
    (i32.const 0)
    (local.get $0)
   )
   (unreachable)
  )
)
