;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_passes_tests_to_lit.py and could be cleaned up.

;; RUN: wasm-opt %s --directize --enable-memory64 -S -o - | filecheck %s

(module
 ;; CHECK:      (type $ii (func (param i32 i32)))
 (type $ii (func (param i32 i32)))

 ;; CHECK:      (table $0 i64 5 5 funcref)
 (table $0 i64 5 5 funcref)

 ;; CHECK:      (elem $elem (i64.const 1) $foo)
 (elem $elem (i64.const 1) $foo)

 ;; CHECK:      (func $foo (param $0 i32) (param $1 i32)
 ;; CHECK-NEXT:  (unreachable)
 ;; CHECK-NEXT: )
 (func $foo (param i32) (param i32)
  ;; helper function
  (unreachable)
 )

 ;; CHECK:      (func $bar (param $x i32) (param $y i32)
 ;; CHECK-NEXT:  (call $foo
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:   (local.get $y)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $bar (param $x i32) (param $y i32)
  (call_indirect (type $ii)
   (local.get $x)
   (local.get $y)
   (i64.const 1)
  )
 )

 ;; CHECK:      (func $bar-32 (param $x i32) (param $y i32)
 ;; CHECK-NEXT:  (unreachable)
 ;; CHECK-NEXT: )
 (func $bar-32 (param $x i32) (param $y i32)
  ;; As above, but the constant has 2**32 added to it. If we operate on a 32-bit
  ;; index, we might think we can optimize to a call to $foo. Instead, we should
  ;; see that this traps, and optimize to that.
  (call_indirect (type $ii)
   (local.get $x)
   (local.get $y)
   (i64.const 4294967297)
  )
 )
)
