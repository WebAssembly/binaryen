;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_test.py and could be cleaned up.

;; RUN: foreach %s %t wasm-opt --remove-unused-brs --all-features -S -o - | filecheck %s

(module
 ;; CHECK:      (type $vector (array (mut i32)))
 (type $vector (array (mut i32)))
 ;; CHECK:      (type $struct (struct (field (ref null $vector))))
 (type $struct (struct (field (ref null $vector))))
 ;; CHECK:      (type $ref|func|_=>_none (func (param (ref func))))

 ;; CHECK:      (type $i32_=>_none (func (param i32)))

 ;; CHECK:      (type $none_=>_ref?|$struct| (func (result (ref null $struct))))

 ;; CHECK:      (type $none_=>_f64 (func (result f64)))

 ;; CHECK:      (type $none_=>_i32 (func (result i32)))

 ;; CHECK:      (type $i32_=>_funcref (func (param i32) (result funcref)))

 ;; CHECK:      (type $none_=>_none (func))

 ;; CHECK:      (import "out" "log" (func $log (param i32)))
 (import "out" "log" (func $log (param i32)))
 ;; CHECK:      (elem declare func $br_on-to-br $br_on-to-flow $i32_=>_none $none_=>_i32)

 ;; CHECK:      (func $foo (result (ref null $struct))
 ;; CHECK-NEXT:  (if (result (ref null $struct))
 ;; CHECK-NEXT:   (i32.const 1)
 ;; CHECK-NEXT:   (struct.new_with_rtt $struct
 ;; CHECK-NEXT:    (array.new_default_with_rtt $vector
 ;; CHECK-NEXT:     (i32.const 1)
 ;; CHECK-NEXT:     (rtt.canon $vector)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (rtt.canon $struct)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (ref.null $struct)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $foo (result (ref null $struct))
  (if (result (ref null $struct))
   (i32.const 1)
   (struct.new_with_rtt $struct
    ;; regression test for computing the cost of an array.new_default, which
    ;; lacks the optional field "init"
    (array.new_default_with_rtt $vector
     (i32.const 1)
     (rtt.canon $vector)
    )
    (rtt.canon $struct)
   )
   (ref.null $struct)
  )
 )

 ;; CHECK:      (func $test-prefinalize (result f64)
 ;; CHECK-NEXT:  (loop $loop (result f64)
 ;; CHECK-NEXT:   (if (result f64)
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:    (f64.const 0)
 ;; CHECK-NEXT:    (block $block (result f64)
 ;; CHECK-NEXT:     (nop)
 ;; CHECK-NEXT:     (br_if $loop
 ;; CHECK-NEXT:      (i32.eqz
 ;; CHECK-NEXT:       (i32.const 0)
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:     (unreachable)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $test-prefinalize (result f64)
  (loop $loop (result f64)
   (block $block (result f64)
    (drop
     (br_if $block
      (f64.const 0)
      (i32.const 1)
     )
    )
    (if
     (i32.const 0)
     (unreachable)
    )
    ;; this will be moved from $block into the if right before it. we must be
    ;; careful to properly finalize() things, as if we finalize the block too
    ;; early - before the if - then the block ends in a none type, which is
    ;; invalid.
    (br $loop)
   )
  )
 )

 ;; CHECK:      (func $none_=>_i32 (result i32)
 ;; CHECK-NEXT:  (unreachable)
 ;; CHECK-NEXT: )
 (func $none_=>_i32 (result i32)
  (unreachable)
 )
 ;; CHECK:      (func $i32_=>_none (param $0 i32)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $i32_=>_none (param i32)
 )
 ;; CHECK:      (func $selectify (param $x i32) (result funcref)
 ;; CHECK-NEXT:  (select (result funcref)
 ;; CHECK-NEXT:   (ref.func $none_=>_i32)
 ;; CHECK-NEXT:   (ref.func $i32_=>_none)
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $selectify (param $x i32) (result funcref)
  ;; this if has arms with different function types, for which funcref is the
  ;; LUB
  (if (result funcref)
   (local.get $x)
   (ref.func $none_=>_i32)
   (ref.func $i32_=>_none)
  )
 )

 ;; CHECK:      (func $br_on-to-br (param $func (ref func))
 ;; CHECK-NEXT:  (call $log
 ;; CHECK-NEXT:   (i32.const 0)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (block $null
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (ref.func $br_on-to-br)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (call $log
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $log
 ;; CHECK-NEXT:   (i32.const 2)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $func (result (ref $ref|func|_=>_none))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (br $func
 ;; CHECK-NEXT:      (ref.func $br_on-to-br)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (call $log
 ;; CHECK-NEXT:     (i32.const 3)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.func $br_on-to-br)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $log
 ;; CHECK-NEXT:   (i32.const 4)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $data (result (ref $vector))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (br $data
 ;; CHECK-NEXT:      (array.new_default_with_rtt $vector
 ;; CHECK-NEXT:       (i32.const 1)
 ;; CHECK-NEXT:       (rtt.canon $vector)
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (call $log
 ;; CHECK-NEXT:     (i32.const 5)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (array.new_default_with_rtt $vector
 ;; CHECK-NEXT:     (i32.const 2)
 ;; CHECK-NEXT:     (rtt.canon $vector)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $log
 ;; CHECK-NEXT:   (i32.const 6)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $i31 (result i31ref)
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (br $i31
 ;; CHECK-NEXT:      (i31.new
 ;; CHECK-NEXT:       (i32.const 42)
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (call $log
 ;; CHECK-NEXT:     (i32.const 7)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (i31.new
 ;; CHECK-NEXT:     (i32.const 1337)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $log
 ;; CHECK-NEXT:   (i32.const 8)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $non-null (result (ref $ref|func|_=>_none))
 ;; CHECK-NEXT:    (br $non-null
 ;; CHECK-NEXT:     (ref.func $br_on-to-br)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (call $log
 ;; CHECK-NEXT:     (i32.const 9)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.func $br_on-to-br)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on-to-br (param $func (ref func))
  (call $log (i32.const 0))
  (block $null
   ;; a non-null reference is not null, and the br is never taken
   (drop
    (br_on_null $null (ref.func $br_on-to-br))
   )
   (call $log (i32.const 1))
  )
  (call $log (i32.const 2))
  (drop
   (block $func (result funcref)
    ;; a non-null function reference means we always take the br
    (drop
     (br_on_func $func (ref.func $br_on-to-br))
    )
    (call $log (i32.const 3))
    (ref.func $br_on-to-br)
   )
  )
  (call $log (i32.const 4))
  (drop
   (block $data (result dataref)
    ;; a non-null data reference means we always take the br
    (drop
     (br_on_data $data
      (array.new_default_with_rtt $vector
       (i32.const 1)
       (rtt.canon $vector)
      )
     )
    )
    (call $log (i32.const 5))
    (array.new_default_with_rtt $vector
     (i32.const 2)
     (rtt.canon $vector)
    )
   )
  )
  (call $log (i32.const 6))
  (drop
   (block $i31 (result i31ref)
    ;; a non-null i31 reference means we always take the br
    (drop
     (br_on_i31 $i31
      (i31.new (i32.const 42))
     )
    )
    (call $log (i32.const 7))
    (i31.new (i32.const 1337))
   )
  )
  (call $log (i32.const 8))
  (drop
   (block $non-null (result (ref func))
    ;; a non-null reference is not null, and the br is always taken
    (br_on_non_null $non-null (ref.func $br_on-to-br))
    (call $log (i32.const 9))
    (ref.func $br_on-to-br)
   )
  )
 )

 ;; a br_on of the obviously incorrect kind can just flow out the value as the
 ;; break is never taken
 ;; CHECK:      (func $br_on-to-flow
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $data (result (ref null data))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (ref.func $br_on-to-flow)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null data)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $datab (result (ref null data))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (i31.new
 ;; CHECK-NEXT:      (i32.const 1337)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null data)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $func (result funcref)
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (array.new_default_with_rtt $vector
 ;; CHECK-NEXT:      (i32.const 2)
 ;; CHECK-NEXT:      (rtt.canon $vector)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null func)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $funcb (result funcref)
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (i31.new
 ;; CHECK-NEXT:      (i32.const 1337)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null func)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $i31 (result (ref null i31))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (array.new_default_with_rtt $vector
 ;; CHECK-NEXT:      (i32.const 2)
 ;; CHECK-NEXT:      (rtt.canon $vector)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null i31)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block $i31b (result (ref null i31))
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (ref.func $br_on-to-flow)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null i31)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on-to-flow
  ;; brs to data
  (drop
   (block $data (result (ref null data))
    (drop
     (br_on_data $data
      (ref.func $br_on-to-flow)
     )
    )
    (ref.null data)
   )
  )
  (drop
   (block $datab (result (ref null data))
    (drop
     (br_on_data $datab
      (i31.new (i32.const 1337))
     )
    )
    (ref.null data)
   )
  )
  ;; brs to func
  (drop
   (block $func (result (ref null func))
    (drop
     (br_on_func $func
      (array.new_default_with_rtt $vector
       (i32.const 2)
       (rtt.canon $vector)
      )
     )
    )
    (ref.null func)
   )
  )
  (drop
   (block $funcb (result (ref null func))
    (drop
     (br_on_func $funcb
      (i31.new (i32.const 1337))
     )
    )
    (ref.null func)
   )
  )
  ;; brs to i31
  (drop
   (block $i31 (result (ref null i31))
    (drop
     (br_on_i31 $i31
      (array.new_default_with_rtt $vector
       (i32.const 2)
       (rtt.canon $vector)
      )
     )
    )
    (ref.null i31)
   )
  )
  (drop
   (block $i31b (result (ref null i31))
    (drop
     (br_on_i31 $i31b
      (ref.func $br_on-to-flow)
     )
    )
    (ref.null i31)
   )
  )
 )
)
