;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --remove-unused-brs -all -S -o - \
;; RUN:  | filecheck %s

(module
 (rec
  ;; CHECK:      (rec
  ;; CHECK-NEXT:  (type $struct (struct ))
  (type $struct (struct))
  ;; CHECK:       (type $struct2 (struct ))
  (type $struct2 (struct))
 )

 ;; CHECK:      (func $br_on-if (type $ref|struct|_=>_none) (param $0 (ref struct))
 ;; CHECK-NEXT:  (block $label
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (select (result (ref struct))
 ;; CHECK-NEXT:     (local.get $0)
 ;; CHECK-NEXT:     (local.get $0)
 ;; CHECK-NEXT:     (i32.const 0)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on-if (param $0 (ref struct))
  (block $label
   (drop
    ;; This br is never taken, as the input is non-nullable, so we can remove
    ;; it. When we do so, we replace it with the if. We should not rescan that
    ;; if, which has already been walked, as that would hit an assertion.
    ;;
    (br_on_null $label
     ;; This if can also be turned into a select, separately from the above
     ;; (that is not specifically intended to be tested here).
     (if (result (ref struct))
      (i32.const 0)
      (local.get $0)
      (local.get $0)
     )
    )
   )
  )
 )

 ;; CHECK:      (func $br_on_cast (type $none_=>_ref|$struct|) (result (ref $struct))
 ;; CHECK-NEXT:  (block $block (result (ref $struct))
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $block
 ;; CHECK-NEXT:     (struct.new_default $struct)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast (result (ref $struct))
  (block $block (result (ref $struct))
   (drop
    ;; This static cast can be computed at compile time: it will definitely be
    ;; taken, so we can turn it into a normal br.
    (br_on_cast $block anyref (ref $struct)
     (struct.new $struct)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $nested_br_on_cast (type $none_=>_i31ref) (result i31ref)
 ;; CHECK-NEXT:  (block $label$1 (result (ref i31))
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $label$1
 ;; CHECK-NEXT:     (i31.new
 ;; CHECK-NEXT:      (i32.const 0)
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $nested_br_on_cast (result i31ref)
  (block $label$1 (result i31ref)
   (drop
    ;; The inner br_on_cast will become a direct br since the type proves it
    ;; is in fact i31. That then becomes unreachable, and the parent must
    ;; handle that properly (do nothing without hitting an assertion).
    (br_on_cast $label$1 (ref any) (ref i31)
     (br_on_cast $label$1 (ref any) (ref i31)
      (i31.new (i32.const 0))
     )
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $br_on_cast_unrelated (type $none_=>_ref?|$struct|) (result (ref null $struct))
 ;; CHECK-NEXT:  (local $nullable-struct2 (ref null $struct2))
 ;; CHECK-NEXT:  (block $block (result nullref)
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (struct.new_default $struct2)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (struct.new_default $struct2)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (local.get $nullable-struct2)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br_on_cast $block (ref null $struct2) nullref
 ;; CHECK-NEXT:     (local.get $nullable-struct2)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast_unrelated (result (ref null $struct))
  (local $nullable-struct2 (ref null $struct2))
  (block $block (result (ref null $struct))
   (drop
    ;; This cast can be computed at compile time: it will definitely fail, so we
    ;; can remove it.
    (br_on_cast $block anyref (ref $struct)
     (struct.new $struct2)
    )
   )
   (drop
    ;; We can still remove it even if the cast allows nulls.
    (br_on_cast $block anyref (ref null $struct)
     (struct.new $struct2)
    )
   )
   (drop
    ;; Or if the cast does not allow nulls and the value is nullable.
    (br_on_cast $block anyref (ref $struct)
     (local.get $nullable-struct2)
    )
   )
   (drop
    ;; But if both are nullable, then we can't optimize because the cast would
    ;; succeed if the value is a null.
    (br_on_cast $block anyref (ref null $struct)
     (local.get $nullable-struct2)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $br_on_cast_fail_unrelated (type $none_=>_anyref) (result anyref)
 ;; CHECK-NEXT:  (local $nullable-struct2 (ref null $struct2))
 ;; CHECK-NEXT:  (block $block (result (ref null $struct2))
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $block
 ;; CHECK-NEXT:     (struct.new_default $struct2)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $block
 ;; CHECK-NEXT:     (struct.new_default $struct2)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $block
 ;; CHECK-NEXT:     (local.get $nullable-struct2)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br_on_cast_fail $block (ref null $struct2) nullref
 ;; CHECK-NEXT:     (local.get $nullable-struct2)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast_fail_unrelated (result anyref)
  (local $nullable-struct2 (ref null $struct2))
  (block $block (result anyref)
   (drop
    ;; This cast can be computed at compile time: it will definitely fail, so we
    ;; can replace it with an unconditional br.
    (br_on_cast_fail $block anyref (ref $struct)
     (struct.new $struct2)
    )
   )
   (drop
    ;; We can still replace it even if the cast allows nulls.
    (br_on_cast_fail $block anyref (ref null $struct)
     (struct.new $struct2)
    )
   )
   (drop
    ;; Or if the cast does not allow nulls and the value is nullable.
    (br_on_cast_fail $block anyref (ref $struct)
     (local.get $nullable-struct2)
    )
   )
   (drop
    ;; But if both are nullable, then we can't optimize because the cast would
    ;; succeed if the value is a null.
    (br_on_cast_fail $block anyref (ref null $struct)
     (local.get $nullable-struct2)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $br_on_cast_no (type $none_=>_ref|$struct|) (result (ref $struct))
 ;; CHECK-NEXT:  (local $struct (ref null $struct))
 ;; CHECK-NEXT:  (block $block (result (ref $struct))
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br_on_cast $block (ref null $struct) (ref $struct)
 ;; CHECK-NEXT:     (local.get $struct)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast_no (result (ref $struct))
  (local $struct (ref null $struct))
  (block $block (result (ref $struct))
   (drop
    (br_on_cast $block anyref (ref $struct)
     ;; As above, but now the type is nullable, so we cannot infer anything.
     (local.get $struct)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $br_on_cast_nullable (type $none_=>_ref?|$struct|) (result (ref null $struct))
 ;; CHECK-NEXT:  (block $block (result nullref)
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br $block
 ;; CHECK-NEXT:     (ref.null none)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast_nullable (result (ref null $struct))
  (block $block (result (ref null $struct))
   (drop
    (br_on_cast $block anyref (ref null $struct)
     ;; As above, but now the cast allows nulls, so we can optimize.
     (ref.null $struct)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $br_on_cast_fail (type $none_=>_ref|$struct|) (result (ref $struct))
 ;; CHECK-NEXT:  (block $block
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (struct.new_default $struct)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (unreachable)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_cast_fail (result (ref $struct))
  (block $block (result (ref $struct))
   (drop
    ;; As $br_on_cast, but this checks for a failing cast, so we know it will
    ;; *not* be taken.
    (br_on_cast_fail $block anyref (ref $struct)
     (struct.new $struct)
    )
   )
   (unreachable)
  )
 )

 ;; CHECK:      (func $casts-are-costly (type $i32_=>_none) (param $x i32)
 ;; CHECK-NEXT:  (local $struct (ref null $struct))
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (if (result i32)
 ;; CHECK-NEXT:    (local.get $x)
 ;; CHECK-NEXT:    (ref.test $struct
 ;; CHECK-NEXT:     (ref.null none)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (i32.const 0)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (if (result anyref)
 ;; CHECK-NEXT:    (local.get $x)
 ;; CHECK-NEXT:    (ref.null none)
 ;; CHECK-NEXT:    (ref.cast null none
 ;; CHECK-NEXT:     (ref.null none)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (if (result anyref)
 ;; CHECK-NEXT:    (local.get $x)
 ;; CHECK-NEXT:    (block $something (result anyref)
 ;; CHECK-NEXT:     (drop
 ;; CHECK-NEXT:      (br_on_cast $something (ref null $struct) (ref $struct)
 ;; CHECK-NEXT:       (local.get $struct)
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:     (ref.null none)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null none)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (select (result anyref)
 ;; CHECK-NEXT:    (block (result anyref)
 ;; CHECK-NEXT:     (block $nothing
 ;; CHECK-NEXT:      (drop
 ;; CHECK-NEXT:       (br_on_null $nothing
 ;; CHECK-NEXT:        (ref.null none)
 ;; CHECK-NEXT:       )
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:     (ref.null none)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (ref.null none)
 ;; CHECK-NEXT:    (local.get $x)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $casts-are-costly (param $x i32)
  ;; We never turn an if into a select if an arm has a cast of any kind, as
  ;; those things involve branches internally, so we'd be adding more than we
  ;; save.
  (local $struct (ref null $struct))
  (drop
   (if (result i32)
    (local.get $x)
    (ref.test $struct
     (ref.null any)
    )
    (i32.const 0)
   )
  )
  (drop
   (if (result anyref)
    (local.get $x)
    (ref.null any)
    (ref.cast null $struct
     (ref.null any)
    )
   )
  )
  (drop
   (if (result anyref)
    (local.get $x)
    (block (result anyref)
     (block $something (result anyref)
      (drop
       (br_on_cast $something anyref (ref $struct)
        (local.get $struct)
       )
      )
      (ref.null any)
     )
    )
    (ref.null any)
   )
  )
  ;; However, null checks are fairly fast, and we will emit a select here.
  (drop
   (if (result anyref)
    (local.get $x)
    (block (result anyref)
     (block $nothing
      (drop
       (br_on_null $nothing
        (ref.null $struct)
       )
      )
     )
     (ref.null any)
    )
    (ref.null any)
   )
  )
 )
)
