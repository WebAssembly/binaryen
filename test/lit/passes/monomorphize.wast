;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --nominal --monomorphize -all -S -o - | filecheck %s

(module
  ;; CHECK:      (type $A (struct_subtype  data))
  (type $A (struct_subtype data))
  ;; CHECK:      (type $B (struct_subtype  $A))
  (type $B (struct_subtype $A))

  ;; CHECK:      (type $ref|$A|_=>_none (func_subtype (param (ref $A)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $ref|$B|_=>_none (func_subtype (param (ref $B)) func))

  ;; CHECK:      (import "a" "b" (func $import (param (ref $A))))
  (import "a" "b" (func $import (param (ref $A))))

  ;; CHECK:      (func $calls (type $none_=>_none)
  ;; CHECK-NEXT:  (call $refinable
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $refinable
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $refinable_0
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $refinable_0
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $calls
    ;; Two calls with $A, two with $B. The calls to $B should both go to the
    ;; same new function which has a refined parameter of $B.
    (call $refinable
      (struct.new $A)
    )
    (call $refinable
      (struct.new $A)
    )
    (call $refinable
      (struct.new $B)
    )
    (call $refinable
      (struct.new $B)
    )
  )

  ;; CHECK:      (func $call-import (type $none_=>_none)
  ;; CHECK-NEXT:  (call $import
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-import
    ;; Calls to imports are left as they are.
    (call $import
      (struct.new $B)
    )
  )

  ;; CHECK:      (func $refinable (type $ref|$A|_=>_none) (param $ref (ref $A))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $refinable (param $ref (ref $A))
    ;; Helper function for the above. Use the parameter to see we update types
    ;; etc when we make a refined version of the function (if we didn't,
    ;; validation would error).
    (drop
      (local.get $ref)
    )
  )
)

;; As above, but now the refinable function uses the local in a way that
;; requires a fixup.
;; CHECK:      (func $refinable_0 (type $ref|$B|_=>_none) (param $ref (ref $B))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (local.get $ref)
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
(module
  ;; CHECK:      (type $A (struct_subtype  data))
  (type $A (struct_subtype data))
  ;; CHECK:      (type $B (struct_subtype  $A))
  (type $B (struct_subtype $A))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $ref|$A|_=>_none (func_subtype (param (ref $A)) func))

  ;; CHECK:      (type $ref|$B|_=>_none (func_subtype (param (ref $B)) func))

  ;; CHECK:      (func $calls (type $none_=>_none)
  ;; CHECK-NEXT:  (call $refinable_0
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $calls
    (call $refinable
      (struct.new $B)
    )
  )

  ;; CHECK:      (func $refinable (type $ref|$A|_=>_none) (param $ref (ref $A))
  ;; CHECK-NEXT:  (local $unref (ref $A))
  ;; CHECK-NEXT:  (local.set $unref
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (local.get $unref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $refinable (param $ref (ref $A))
    (local $unref (ref $A))
    (local.set $unref
      (local.get $ref)
    )
    ;; If we refine $ref then this set will be invalid - we'd be setting a less-
    ;; refined type into a local/param that is more refined. We should fix this
    ;; up by using a temp local.
    (local.set $ref
      (local.get $unref)
    )
  )
)

;; Multiple refinings of the same function, and of different functions.
;; CHECK:      (func $refinable_0 (type $ref|$B|_=>_none) (param $ref (ref $B))
;; CHECK-NEXT:  (local $unref (ref $A))
;; CHECK-NEXT:  (local $2 (ref $A))
;; CHECK-NEXT:  (local.set $2
;; CHECK-NEXT:   (local.get $ref)
;; CHECK-NEXT:  )
;; CHECK-NEXT:  (block
;; CHECK-NEXT:   (local.set $unref
;; CHECK-NEXT:    (local.get $2)
;; CHECK-NEXT:   )
;; CHECK-NEXT:   (local.set $2
;; CHECK-NEXT:    (local.get $unref)
;; CHECK-NEXT:   )
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
(module
  ;; CHECK:      (type $A (struct_subtype  data))
  (type $A (struct_subtype data))
  ;; CHECK:      (type $B (struct_subtype  $A))
  (type $B (struct_subtype $A))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $C (struct_subtype  $B))
  (type $C (struct_subtype $B))

  ;; CHECK:      (type $ref|$A|_=>_none (func_subtype (param (ref $A)) func))

  ;; CHECK:      (type $ref|$B|_=>_none (func_subtype (param (ref $B)) func))

  ;; CHECK:      (type $ref|$C|_=>_none (func_subtype (param (ref $C)) func))

  ;; CHECK:      (func $calls1 (type $none_=>_none)
  ;; CHECK-NEXT:  (call $refinable1
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $refinable1_0
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $calls1
    (call $refinable1
      (struct.new $A)
    )
    (call $refinable1
      (struct.new $B)
    )
  )

  ;; CHECK:      (func $calls2 (type $none_=>_none)
  ;; CHECK-NEXT:  (call $refinable1_1
  ;; CHECK-NEXT:   (struct.new_default $C)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $refinable2_0
  ;; CHECK-NEXT:   (struct.new_default $B)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $calls2
    (call $refinable1
      (struct.new $C)
    )
    (call $refinable2
      (struct.new $B)
    )
  )

  ;; CHECK:      (func $refinable1 (type $ref|$A|_=>_none) (param $ref (ref $A))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $refinable1 (param $ref (ref $A))
    (drop
      (local.get $ref)
    )
  )

  ;; CHECK:      (func $refinable2 (type $ref|$A|_=>_none) (param $ref (ref $A))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $refinable2 (param $ref (ref $A))
    (drop
      (local.get $ref)
    )
  )
)
;; CHECK:      (func $refinable1_0 (type $ref|$B|_=>_none) (param $ref (ref $B))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (local.get $ref)
;; CHECK-NEXT:  )
;; CHECK-NEXT: )

;; CHECK:      (func $refinable1_1 (type $ref|$C|_=>_none) (param $ref (ref $C))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (local.get $ref)
;; CHECK-NEXT:  )
;; CHECK-NEXT: )

;; CHECK:      (func $refinable2_0 (type $ref|$B|_=>_none) (param $ref (ref $B))
;; CHECK-NEXT:  (drop
;; CHECK-NEXT:   (local.get $ref)
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
