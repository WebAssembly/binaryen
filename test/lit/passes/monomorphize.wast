;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; Test in both "always" mode, which always monomorphizes, and in "careful"
;; mode which does it only when it appears to actually help.

;; RUN: foreach %s %t wasm-opt --nominal --monomorphize-always -all -S -o - | filecheck %s --check-prefix ALWAYS
;; RUN: foreach %s %t wasm-opt --nominal --monomorphize-always -all -S -o - | filecheck %s --check-prefix CAREFUL

(module
  (type $A (struct_subtype data))
  (type $B (struct_subtype $A))

  (import "a" "b" (func $import (param (ref $A))))

  (func $calls
    ;; Two calls with $A, two with $B. The calls to $B should both go to the
    ;; same new function which has a refined parameter of $B.
    (call $refinable
      (struct.new $A)
    )
    (call $refinable
      (struct.new $A)
    )
    (call $refinable
      (struct.new $B)
    )
    (call $refinable
      (struct.new $B)
    )
  )

  (func $call-import
    ;; Calls to imports are left as they are.
    (call $import
      (struct.new $B)
    )
  )

  (func $refinable (param $ref (ref $A))
    ;; Helper function for the above. Use the parameter to see we update types
    ;; etc when we make a refined version of the function (if we didn't,
    ;; validation would error).
    (drop
      (local.get $ref)
    )
  )
)

;; As above, but now the refinable function uses the local in a way that
;; requires a fixup.
(module
  (type $A (struct_subtype data))
  (type $B (struct_subtype $A))



  (func $calls
    (call $refinable
      (struct.new $B)
    )
  )

  (func $refinable (param $ref (ref $A))
    (local $unref (ref $A))
    (local.set $unref
      (local.get $ref)
    )
    ;; If we refine $ref then this set will be invalid - we'd be setting a less-
    ;; refined type into a local/param that is more refined. We should fix this
    ;; up by using a temp local.
    (local.set $ref
      (local.get $unref)
    )
  )
)

;; Multiple refinings of the same function, and of different functions.
(module
  (type $A (struct_subtype data))
  (type $B (struct_subtype $A))

  (type $C (struct_subtype $B))

  (func $calls1
    (call $refinable1
      (struct.new $A)
    )
    (call $refinable1
      (struct.new $B)
    )
  )

  (func $calls2
    (call $refinable1
      (struct.new $C)
    )
    (call $refinable2
      (struct.new $B)
    )
  )

  (func $refinable1 (param $ref (ref $A))
    (drop
      (local.get $ref)
    )
  )

  (func $refinable2 (param $ref (ref $A))
    (drop
      (local.get $ref)
    )
  )
)
