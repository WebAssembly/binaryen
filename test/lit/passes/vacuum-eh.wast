;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --vacuum -all -S -o - | filecheck %s

(module
  ;; CHECK:      (tag $e (param i32))
  (tag $e (param i32))
  ;; CHECK:      (tag $e2 (param i32))
  (tag $e2 (param i32))

  ;; CHECK:      (func $try-test
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $try-test
    ;; When try body does not throw, try-body can be replaced with the try body
    (try
      (do
        (drop (i32.const 0))
      )
      (catch $e
        (drop (pop i32))
      )
    )
  )

  ;; CHECK:      (func $inner-try-catch_all-test
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (try $try0
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (throw $e
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch_all
  ;; CHECK-NEXT:    (local.set $0
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $inner-try-catch_all-test (local $0 i32)
    ;; The exception thrown in the inner try is caught by the inner catch_all,
    ;; so the outer try body does not throw and the outer try-catch can be
    ;; removed
    (try
      (do
        (try
          (do
            (throw $e (i32.const 0))
          )
          (catch_all
            (local.set $0 (i32.const 1))
          )
        )
      )
      (catch $e
        (drop (pop i32))
      )
    )
  )

  ;; CHECK:      (func $inner-try-catch-test
  ;; CHECK-NEXT:  (local $0 i32)
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (try $try1
  ;; CHECK-NEXT:     (do
  ;; CHECK-NEXT:      (throw $e2
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (catch $e
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (pop i32)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (local.set $0
  ;; CHECK-NEXT:       (i32.const 1)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $e
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (pop i32)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $inner-try-catch-test (local $0 i32)
    ;; The exception thrown in the inner try will not be caught by the inner
    ;; catch, so the outer try-catch cannot be removed
    (try
      (do
        (try
          (do
            (throw $e2 (i32.const 0))
          )
          (catch $e
            (drop (pop i32))
            (local.set $0 (i32.const 1))
          )
        )
      )
      (catch $e
        (drop (pop i32))
      )
    )
  )

  ;; CHECK:      (func $br-in-catch
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $br-in-catch
    ;; When catch body is removed, the removal of 'br' inside the catch body
    ;; should be propagated up to the outer block, so that its type will be
    ;; correctly updated to unreachable.
    (block $label$1
      (try
        (do
          (unreachable)
        )
        (catch $e
          (drop (pop i32))
          (br $label$1)
        )
      )
    )
  )
)
