;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --nominal --remove-unused-names --gufa -all -S -o - | filecheck %s
;; (remove-unused-names is added to test fallthrough values without a block
;; name getting in the way)

;; This is almost identical to cfp.wast, and is meant to facilitate comparisons
;; between the passes - in particular, gufa should do everything cfp can do,
;; although it may do it differently. Changes include:
;;
;;  * Tests must avoid things gufa optimizes away that would make the test
;;    irrelevant. In particular, parameters to functions that are never called
;;    will be turned to unreachable by gufa, so instead make those calls to
;;    imports. Gufa will also realize that passing ref.null to a struct.get/set
;;    can be optimized (as no actual allocation is created there), so avoid that
;;    and store allocations in locals (instead of dropping them and using
;;    ref.null later; replace the ref.null with a local.get).
;;  * Gufa optimizes in a more general way. Cfp will turn a struct.get whose
;;    value it infers into a ref.as_non_null (to preserve the trap if the ref is
;;    null) followed by the constant. Gufa has no special handling for
;;    struct.get, so it will use its normal pattern there, of a drop of the
;;    struct.get followed by the constant. (Other passes can remove the
;;    dropped operation, like vacuum in trapsNeverHappen mode).
;;  * Gufa's more general optimizations can remove more unreachable code, as it
;;    checks for effects (and removes effectless code).

(module
  (type $struct (struct i32))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $impossible-get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $impossible-get
    (drop
      ;; This type is never created, so a get is impossible, and we will trap
      ;; anyhow. So we can turn this into an unreachable.
      (struct.get $struct 0
        (ref.null $struct)
      )
    )
  )
)

(module
  (type $struct (struct i64))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i64.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The only place this type is created is with a default value, and so we
    ;; can optimize the later get into a constant (note that no drop of the
    ;; ref is needed: the optimize can see that the struct.get cannot trap, as
    ;; its reference is non-nullable).
    (drop
      (struct.get $struct 0
        (struct.new_default_with_rtt $struct
          (rtt.canon $struct)
        )
      )
    )
  )
)

(module
  (type $struct (struct f32))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (f32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The only place this type is created is with a constant value, and so we
    ;; can optimize to a constant, the same as above (but the constant was
    ;; passed in, as opposed to being a default value as in the last testcase).
    (drop
      (struct.get $struct 0
        (struct.new_with_rtt $struct
          (f32.const 42)
          (rtt.canon $struct)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field f32) data))
  (type $struct (struct f32))

  ;; CHECK:      (type $none_=>_f32 (func_subtype (result f32) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (func $import (result f32)))
  (import "a" "b" (func $import (result f32)))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (struct.new_with_rtt $struct
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:     (rtt.canon $struct)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The value given is not a constant, and so we cannot optimize.
    (drop
      (struct.get $struct 0
        (struct.new_with_rtt $struct
          (call $import)
          (rtt.canon $struct)
        )
      )
    )
  )
)

;; Create in one function, get in another. The 10 should be forwarded to the
;; get.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))
  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (i32.const 10)
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    ;; The reference will be dropped here, and not removed entirely, because
    ;; the optimizer thinks it might have side effects (since it has a call).
    ;; But the forwarded value, 10, is applied after that drop.
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

;; As before, but with the order of functions reversed to check for any ordering
;; issues.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (i32.const 10)
      (rtt.canon $struct)
    )
  )
)

;; Different values assigned in the same function, in different struct.news,
;; so we cannot optimize the struct.get away.
(module
  ;; CHECK:      (type $struct (struct_subtype (field f32) data))
  (type $struct (struct f32))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (f32.const 42)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (struct.new_with_rtt $struct
  ;; CHECK-NEXT:     (f32.const 1337)
  ;; CHECK-NEXT:     (rtt.canon $struct)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (drop
      (struct.new_with_rtt $struct
        (f32.const 42)
        (rtt.canon $struct)
      )
    )
    ;; (A better analysis could see that the first struct.new is dropped.)
    (drop
      (struct.get $struct 0
        (struct.new_with_rtt $struct
          (f32.const 1337)
          (rtt.canon $struct)
        )
      )
    )
  )
)

;; Different values assigned in different functions, and one is a struct.set.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut f32)) data))
  (type $struct (struct (mut f32)))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (f32.const 42)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (f32.const 42)
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $set (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:   (f32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $set
    (struct.set $struct 0
      (call $create)
      (f32.const 1337)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

;; As the last testcase, but the values happen to coincide, so we can optimize
;; the get into a constant.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut f32)) data))
  (type $struct (struct (mut f32)))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (f32.const 42)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (f32.const 42)
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $set (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:   (f32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $set
    (struct.set $struct 0
      (call $create)
      (f32.const 42) ;; The last testcase had 1337 here.
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

;; Check that we look into the fallthrough value that is assigned.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut f32)) data))
  (type $struct (struct (mut f32)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (block (result f32)
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:    (f32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      ;; Fall though a 42 via a block.
      (block (result f32)
        (nop)
        (f32.const 42)
      )
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $set (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:   (block (result f32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (if (result f32)
  ;; CHECK-NEXT:      (call $import)
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:      (f32.const 42)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $set
    (struct.set $struct 0
      (call $create)
      ;; Fall though a 42 via an if.
      (if (result f32)
        (call $import)
        (unreachable)
        (f32.const 42)
      )
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

;; Test a function reference instead of a number.
(module
  (type $struct (struct funcref))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (elem declare func $test)

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.func $test)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (drop
      (struct.get $struct 0
        (struct.new_with_rtt $struct
          (ref.func $test)
          (rtt.canon $struct)
        )
      )
    )
  )
)

;; Test for unreachable creations, sets, and gets.
(module
  (type $struct (struct (mut i32)))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (drop
      (struct.new_with_rtt $struct
        (i32.const 10)
        (unreachable)
      )
    )
    (struct.set $struct 0
      (struct.get $struct 0
        (unreachable)
      )
      (i32.const 20)
    )
  )
)

;; Subtyping: Create a supertype and get a subtype. As we never create a
;;            subtype, the get must trap anyhow (the reference it receives can
;;            only be null in this closed world).
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))
  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $substruct (struct_subtype (field i32) $struct))
  (type $substruct (struct_subtype i32 $struct))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (i32.const 10)
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (block
  ;; CHECK-NEXT:        (drop
  ;; CHECK-NEXT:         (ref.cast_static $substruct
  ;; CHECK-NEXT:          (call $create)
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (unreachable)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $substruct 0
        (ref.cast_static $substruct
          (call $create)
        )
      )
    )
  )
)

;; As above, but in addition to a new of $struct also add a set. The set,
;; however, cannot write to the subtype, so we still know that any reads from
;; the subtype must trap.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))
  (type $substruct (struct_subtype (mut i32) $struct))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (struct.set $struct 0
      (ref.null $struct)
      (i32.const 10)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $substruct 0
        (ref.null $substruct)
      )
    )
  )
)

;; As above, pass the created supertype through a local and a cast on the way
;; to a read of the subtype. Still, no actual instance of the subtype can
;; appear in the get, so we can optimize the value. The cast can also be
;; optimized, since we know it will trap.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))
  ;; CHECK:      (type $substruct (struct_subtype (field (mut i32)) $struct))
  (type $substruct (struct_subtype (mut i32) $struct))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref null $substruct))
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (ref.cast_static $substruct
  ;; CHECK-NEXT:        (local.get $ref)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null $substruct)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 10)
    )
    (drop
      (struct.get $substruct 0
        (ref.cast_static $substruct
          (local.get $ref)
        )
      )
    )
  )
)

;; Subtyping: Create a subtype and get a supertype. The get must receive a
;;            reference to the subtype (we never create a supertype) and so we
;;            can optimize.
(module
  (type $substruct (struct_subtype i32 f64 $struct))

  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (drop
      (struct.get $struct 0
        (struct.new_with_rtt $substruct
          (i32.const 10)
          (f64.const 3.14159)
          (rtt.canon $substruct)
        )
      )
    )
  )
)

;; Subtyping: Create both a subtype and a supertype, with identical constants
;;            for the shared field, and get the supertype.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $substruct (struct_subtype (field i32) (field f64) $struct))
  (type $substruct (struct_subtype i32 f64 $struct))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $substruct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:    (rtt.canon $substruct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (local.set $ref
      (struct.new_with_rtt $substruct
        (i32.const 10)
        (f64.const 3.14159)
        (rtt.canon $substruct)
      )
    )
    (drop
      (struct.get $struct 0
        (local.get $ref)
      )
    )
  )
)

;; Subtyping: Create both a subtype and a supertype, with different constants
;;            for the shared field, preventing optimization, as a get of the
;;            supertype may receive an instance of the subtype.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $substruct (struct_subtype (field i32) (field f64) $struct))
  (type $substruct (struct_subtype i32 f64 $struct))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $substruct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:    (rtt.canon $substruct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (local.set $ref
      (struct.new_with_rtt $substruct
        (i32.const 20) ;; this constant changed
        (f64.const 3.14159)
        (rtt.canon $substruct)
      )
    )
    (drop
      (struct.get $struct 0
        (local.get $ref)
      )
    )
  )
)

;; Subtyping: Create both a subtype and a supertype, with different constants
;;            for the shared field, but get from the subtype. The field is
;;            shared between the types, but we only create the substruct with
;;            one value, so we can optimize.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $substruct (struct_subtype (field i32) (field f64) $struct))
  (type $substruct (struct_subtype i32 f64 $struct))

  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $substruct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:    (rtt.canon $substruct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $substruct 0
  ;; CHECK-NEXT:      (ref.cast_static $substruct
  ;; CHECK-NEXT:       (local.get $ref)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (local.set $ref
      (struct.new_with_rtt $substruct
        (i32.const 20) ;; this constant changed
        (f64.const 3.14159)
        (rtt.canon $substruct)
      )
    )
    (drop
      (struct.get $substruct 0
        (ref.cast_static $substruct
          (local.get $ref)
        )
      )
    )
  )
)

;; As above, but add a set of $struct. The set prevents the optimization.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $substruct (struct_subtype (field (mut i32)) (field f64) $struct))
  (type $substruct (struct_subtype (mut i32) f64 $struct))


  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $substruct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:    (rtt.canon $substruct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $substruct 0
  ;; CHECK-NEXT:    (ref.cast_static $substruct
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (local.set $ref
      (struct.new_with_rtt $substruct
        (i32.const 20)
        (f64.const 3.14159)
        (rtt.canon $substruct)
      )
    )
    ;; This set is added. Even though the type is the super, this writes to the
    ;; child, and so we cannot optimize.
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 10)
    )
    (drop
      (struct.get $substruct 0
        (ref.cast_static $substruct
          (local.get $ref)
        )
      )
    )
  )
)

;; As above, but now the constants agree.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $substruct (struct_subtype (field (mut i32)) (field f64) $struct))
  (type $substruct (struct_subtype (mut i32) f64 $struct))


  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (rtt.canon $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new_with_rtt $substruct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:    (rtt.canon $substruct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $substruct 0
  ;; CHECK-NEXT:      (ref.cast_static $substruct
  ;; CHECK-NEXT:       (local.get $ref)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new_with_rtt $struct
        (i32.const 10)
        (rtt.canon $struct)
      )
    )
    (local.set $ref
      (struct.new_with_rtt $substruct
        (i32.const 20)
        (f64.const 3.14159)
        (rtt.canon $substruct)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      ;; This now writes the same value as in the $substruct already has, 20, so
      ;; we can optimize the get below. Note that the the $struct has 10 there,
      ;; but that does not stop us.
      (i32.const 20)
    )
    (drop
      (struct.get $substruct 0
        (ref.cast_static $substruct
          (local.get $ref)
        )
      )
    )
  )
)

;; Multi-level subtyping, check that we propagate not just to the immediate
;; supertype but all the way as needed.
(module
  ;; CHECK:      (type $struct1 (struct_subtype (field i32) data))

  ;; CHECK:      (type $struct2 (struct_subtype (field i32) (field f64) $struct1))

  ;; CHECK:      (type $struct3 (struct_subtype (field i32) (field f64) (field anyref) $struct2))
  (type $struct3 (struct_subtype i32 f64 anyref $struct2))

  (type $struct2 (struct_subtype i32 f64 $struct1))

  (type $struct1 (struct i32))

  ;; CHECK:      (type $none_=>_ref|$struct3| (func_subtype (result (ref $struct3)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct3|) (result (ref $struct3))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct3
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:   (f64.const 3.14159)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:   (rtt.canon $struct3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct3))
    (struct.new_with_rtt $struct3
      (i32.const 20)
      (f64.const 3.14159)
      (ref.null any)
      (rtt.canon $struct3)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct3))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 1
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 1
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 2
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (local $ref (ref null $struct3))
    (local.set $ref
      (call $create)
    )
    ;; Get field 0 from the $struct1. This can be optimized to a constant
    ;; since we only ever created an instance of struct3 with a constant there.
    (drop
      (struct.get $struct1 0
        (local.get $ref)
      )
    )
    ;; Get both fields of $struct2.
    (drop
      (struct.get $struct2 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $struct2 1
        (local.get $ref)
      )
    )
    ;; Get all 3 fields of $struct3
    (drop
      (struct.get $struct3 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $struct3 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $struct3 2
        (local.get $ref)
      )
    )
  )
)

;; Multi-level subtyping with conflicts. The even-numbered fields will get
;; different values in the sub-most type. Create the top and bottom types, but
;; not the middle one.
(module
  ;; CHECK:      (type $struct1 (struct_subtype (field i32) (field i32) data))

  ;; CHECK:      (type $struct2 (struct_subtype (field i32) (field i32) (field f64) (field f64) $struct1))

  ;; CHECK:      (type $struct3 (struct_subtype (field i32) (field i32) (field f64) (field f64) (field anyref) (field anyref) $struct2))
  (type $struct3 (struct_subtype i32 i32 f64 f64 anyref anyref $struct2))

  (type $struct1 (struct i32 i32))

  (type $struct2 (struct_subtype i32 i32 f64 f64 $struct1))

  ;; CHECK:      (type $none_=>_anyref (func_subtype (result anyref) func))

  ;; CHECK:      (type $none_=>_ref|$struct1| (func_subtype (result (ref $struct1)) func))

  ;; CHECK:      (type $none_=>_ref|$struct3| (func_subtype (result (ref $struct3)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (func $import (result anyref)))
  (import "a" "b" (func $import (result anyref)))

  ;; CHECK:      (func $create1 (type $none_=>_ref|$struct1|) (result (ref $struct1))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct1
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:   (rtt.canon $struct1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create1 (result (ref $struct1))
    (struct.new_with_rtt $struct1
      (i32.const 10)
      (i32.const 20)
      (rtt.canon $struct1)
    )
  )

  ;; CHECK:      (func $create3 (type $none_=>_ref|$struct3|) (result (ref $struct3))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct3
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (i32.const 999)
  ;; CHECK-NEXT:   (f64.const 2.71828)
  ;; CHECK-NEXT:   (f64.const 9.9999999)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:   (call $import)
  ;; CHECK-NEXT:   (rtt.canon $struct3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create3 (result (ref $struct3))
    (struct.new_with_rtt $struct3
      (i32.const 10)
      (i32.const 999) ;; use a different value here
      (f64.const 2.71828)
      (f64.const 9.9999999)
      (ref.null any)
      (call $import) ;; use an unknown value here, which can never be
                     ;; optimized.
      (rtt.canon $struct3)
    )
  )

  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 0
  ;; CHECK-NEXT:      (call $create1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 1
  ;; CHECK-NEXT:      (call $create1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 1
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 999)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 2
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f64.const 2.71828)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 3
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f64.const 9.9999999)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 4
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct3 5
  ;; CHECK-NEXT:    (call $create3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    ;; Get all the fields of all the structs.
    (drop
      (struct.get $struct1 0
        (call $create1)
      )
    )
    (drop
      (struct.get $struct1 1
        (call $create1)
      )
    )
    ;; $struct2 is never created, and only accessed via nulls; all these should
    ;; trap.
    (drop
      (struct.get $struct2 0
        (ref.null $struct2)
      )
    )
    (drop
      (struct.get $struct2 1
        (ref.null $struct2)
      )
    )
    (drop
      (struct.get $struct2 2
        (ref.null $struct2)
      )
    )
    (drop
      (struct.get $struct2 3
        (ref.null $struct2)
      )
    )
    (drop
      (struct.get $struct3 0
        (call $create3)
      )
    )
    (drop
      (struct.get $struct3 1
        (call $create3)
      )
    )
    (drop
      (struct.get $struct3 2
        (call $create3)
      )
    )
    (drop
      (struct.get $struct3 3
        (call $create3)
      )
    )
    (drop
      (struct.get $struct3 4
        (call $create3)
      )
    )
    (drop
      (struct.get $struct3 5
        (call $create3)
      )
    )
  )
)

;; Multi-level subtyping with a different value in the middle of the chain.
(module
  ;; CHECK:      (type $struct1 (struct_subtype (field (mut i32)) data))
  (type $struct1 (struct (mut i32)))
  ;; CHECK:      (type $struct2 (struct_subtype (field (mut i32)) (field f64) $struct1))
  (type $struct2 (struct_subtype (mut i32) f64 $struct1))
  ;; CHECK:      (type $struct3 (struct_subtype (field (mut i32)) (field f64) (field anyref) $struct2))
  (type $struct3 (struct_subtype (mut i32) f64 anyref $struct2))


  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|$struct1| (func_subtype (result (ref $struct1)) func))

  ;; CHECK:      (type $none_=>_ref|$struct2| (func_subtype (result (ref $struct2)) func))

  ;; CHECK:      (type $none_=>_ref|$struct3| (func_subtype (result (ref $struct3)) func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $create1 (type $none_=>_ref|$struct1|) (result (ref $struct1))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct1
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create1 (result (ref $struct1))
    (struct.new_with_rtt $struct1
      (i32.const 10)
      (rtt.canon $struct1)
    )
  )

  ;; CHECK:      (func $create2 (type $none_=>_ref|$struct2|) (result (ref $struct2))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct2
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (rtt.canon $struct2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create2 (result (ref $struct2))
    (struct.new_with_rtt $struct2
      (i32.const 9999) ;; use a different value here
      (f64.const 0)
      (rtt.canon $struct2)
    )
  )

  ;; CHECK:      (func $create3 (type $none_=>_ref|$struct3|) (result (ref $struct3))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct3
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:   (rtt.canon $struct3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create3 (result (ref $struct3))
    (struct.new_with_rtt $struct3
      (i32.const 10)
      (f64.const 0)
      (ref.null any)
      (rtt.canon $struct3)
    )
  )

  ;; CHECK:      (func $get-precise (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 0
  ;; CHECK-NEXT:      (call $create1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct2 0
  ;; CHECK-NEXT:      (call $create2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 9999)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-precise
    ;; Get field 0 in all the types. We know precisely what the type is in each
    ;; case here, so we can optimize all of these.
    (drop
      (struct.get $struct1 0
        (call $create1)
      )
    )
    (drop
      (struct.get $struct2 0
        (call $create2)
      )
    )
    (drop
      (struct.get $struct3 0
        (call $create3)
      )
    )
  )

  ;; CHECK:      (func $get-imprecise-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 0
  ;; CHECK-NEXT:      (select (result (ref $struct1))
  ;; CHECK-NEXT:       (call $create1)
  ;; CHECK-NEXT:       (call $create1)
  ;; CHECK-NEXT:       (call $import)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct1 0
  ;; CHECK-NEXT:    (select (result (ref $struct1))
  ;; CHECK-NEXT:     (call $create1)
  ;; CHECK-NEXT:     (call $create2)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct1 0
  ;; CHECK-NEXT:    (select (result (ref $struct1))
  ;; CHECK-NEXT:     (call $create1)
  ;; CHECK-NEXT:     (call $create3)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-imprecise-1
    ;; Check the results of reading from a ref that can be one of two things.
    ;; We check all permutations in the arms of the select in this function and
    ;; the next two.
    ;;
    ;; Atm we can only optimize when the ref is the same in both arms, since
    ;; even if two different types agree on the value (like $struct1 and
    ;; $struct3 do), once we see two different types we already see the type as
    ;; imprecise, and $struct2 in the middle has a different value, so imprecise
    ;; info is not enough.
    (drop
      (struct.get $struct1 0
        (select
          (call $create1)
          (call $create1)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create1)
          (call $create2)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create1)
          (call $create3)
          (call $import)
        )
      )
    )
  )

  ;; CHECK:      (func $get-imprecise-2 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct1 0
  ;; CHECK-NEXT:    (select (result (ref $struct1))
  ;; CHECK-NEXT:     (call $create2)
  ;; CHECK-NEXT:     (call $create1)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct2 0
  ;; CHECK-NEXT:      (select (result (ref $struct2))
  ;; CHECK-NEXT:       (call $create2)
  ;; CHECK-NEXT:       (call $create2)
  ;; CHECK-NEXT:       (call $import)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 9999)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct2 0
  ;; CHECK-NEXT:    (select (result (ref $struct2))
  ;; CHECK-NEXT:     (call $create2)
  ;; CHECK-NEXT:     (call $create3)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-imprecise-2
    (drop
      (struct.get $struct1 0
        (select
          (call $create2)
          (call $create1)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create2)
          (call $create2)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create2)
          (call $create3)
          (call $import)
        )
      )
    )
  )

  ;; CHECK:      (func $get-imprecise-3 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct1 0
  ;; CHECK-NEXT:    (select (result (ref $struct1))
  ;; CHECK-NEXT:     (call $create3)
  ;; CHECK-NEXT:     (call $create1)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct2 0
  ;; CHECK-NEXT:    (select (result (ref $struct2))
  ;; CHECK-NEXT:     (call $create3)
  ;; CHECK-NEXT:     (call $create2)
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (select (result (ref $struct3))
  ;; CHECK-NEXT:       (call $create3)
  ;; CHECK-NEXT:       (call $create3)
  ;; CHECK-NEXT:       (call $import)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-imprecise-3
    (drop
      (struct.get $struct1 0
        (select
          (call $create3)
          (call $create1)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create3)
          (call $create2)
          (call $import)
        )
      )
    )
    (drop
      (struct.get $struct1 0
        (select
          (call $create3)
          (call $create3)
          (call $import)
        )
      )
    )
  )
)

;; As above, but add not just a new of the middle class with a different value
;; but also a set. We can see that the set just affects the middle class,
;; though, so it is not a problem.
(module
  ;; CHECK:      (type $struct1 (struct_subtype (field (mut i32)) data))
  (type $struct1 (struct (mut i32)))
  ;; CHECK:      (type $struct2 (struct_subtype (field (mut i32)) (field f64) $struct1))
  (type $struct2 (struct_subtype (mut i32) f64 $struct1))
  ;; CHECK:      (type $struct3 (struct_subtype (field (mut i32)) (field f64) (field anyref) $struct2))
  (type $struct3 (struct_subtype (mut i32) f64 anyref $struct2))


  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|$struct1| (func_subtype (result (ref $struct1)) func))

  ;; CHECK:      (type $none_=>_ref|$struct2| (func_subtype (result (ref $struct2)) func))

  ;; CHECK:      (type $none_=>_ref|$struct3| (func_subtype (result (ref $struct3)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $create1 (type $none_=>_ref|$struct1|) (result (ref $struct1))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct1
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create1 (result (ref $struct1))
    (struct.new_with_rtt $struct1
      (i32.const 10)
      (rtt.canon $struct1)
    )
  )

  ;; CHECK:      (func $create2 (type $none_=>_ref|$struct2|) (result (ref $struct2))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct2
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (rtt.canon $struct2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create2 (result (ref $struct2))
    (struct.new_with_rtt $struct2
      (i32.const 9999) ;; use a different value here
      (f64.const 0)
      (rtt.canon $struct2)
    )
  )

  ;; CHECK:      (func $create3 (type $none_=>_ref|$struct3|) (result (ref $struct3))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct3
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:   (rtt.canon $struct3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create3 (result (ref $struct3))
    (struct.new_with_rtt $struct3
      (i32.const 10)
      (f64.const 0)
      (ref.null any)
      (rtt.canon $struct3)
    )
  )

  ;; CHECK:      (func $get-precise (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 0
  ;; CHECK-NEXT:      (call $create1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (call $create2)
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct2 0
  ;; CHECK-NEXT:      (call $create2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 9999)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-precise
    (drop
      (struct.get $struct1 0
        (call $create1)
      )
    )
    (struct.set $struct2 0
      (call $create2)
      (i32.const 9999)
    )
    (drop
      (struct.get $struct2 0
        (call $create2)
      )
    )
    (drop
      (struct.get $struct3 0
        (call $create3)
      )
    )
  )
)

;; As above, but the set is of a different value.
(module
  ;; CHECK:      (type $struct1 (struct_subtype (field (mut i32)) data))
  (type $struct1 (struct (mut i32)))
  ;; CHECK:      (type $struct2 (struct_subtype (field (mut i32)) (field f64) $struct1))
  (type $struct2 (struct_subtype (mut i32) f64 $struct1))
  ;; CHECK:      (type $struct3 (struct_subtype (field (mut i32)) (field f64) (field anyref) $struct2))
  (type $struct3 (struct_subtype (mut i32) f64 anyref $struct2))


  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|$struct1| (func_subtype (result (ref $struct1)) func))

  ;; CHECK:      (type $none_=>_ref|$struct2| (func_subtype (result (ref $struct2)) func))

  ;; CHECK:      (type $none_=>_ref|$struct3| (func_subtype (result (ref $struct3)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $create1 (type $none_=>_ref|$struct1|) (result (ref $struct1))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct1
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $struct1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create1 (result (ref $struct1))
    (struct.new_with_rtt $struct1
      (i32.const 10)
      (rtt.canon $struct1)
    )
  )

  ;; CHECK:      (func $create2 (type $none_=>_ref|$struct2|) (result (ref $struct2))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct2
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (rtt.canon $struct2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create2 (result (ref $struct2))
    (struct.new_with_rtt $struct2
      (i32.const 9999) ;; use a different value here
      (f64.const 0)
      (rtt.canon $struct2)
    )
  )

  ;; CHECK:      (func $create3 (type $none_=>_ref|$struct3|) (result (ref $struct3))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct3
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:   (rtt.canon $struct3)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create3 (result (ref $struct3))
    (struct.new_with_rtt $struct3
      (i32.const 10)
      (f64.const 0)
      (ref.null any)
      (rtt.canon $struct3)
    )
  )

  ;; CHECK:      (func $get-precise (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct1 0
  ;; CHECK-NEXT:      (call $create1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (call $create2)
  ;; CHECK-NEXT:   (i32.const 1234)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct2 0
  ;; CHECK-NEXT:    (call $create2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct3 0
  ;; CHECK-NEXT:      (call $create3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-precise
    (drop
      (struct.get $struct1 0
        (call $create1)
      )
    )
    ;; This set of a different value limits our ability to optimize the get
    ;; after us.
    (struct.set $struct2 0
      (call $create2)
      (i32.const 1234)
    )
    (drop
      (struct.get $struct2 0
        (call $create2)
      )
    )
    (drop
      (struct.get $struct3 0
        (call $create3)
      )
    )
  )
)

;; Test for a struct with multiple fields, some of which are constant and hence
;; optimizable, and some not. Also test that some have the same type.
(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) (field f64) (field i32) (field f64) (field i32) data))
  (type $struct (struct i32 f64 i32 f64 i32))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_with_rtt $struct
  ;; CHECK-NEXT:   (i32.eqz
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (f64.const 3.14159)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:   (f64.abs
  ;; CHECK-NEXT:    (f64.const 2.71828)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 30)
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_with_rtt $struct
      (i32.eqz (i32.const 10)) ;; not a constant (as far as this pass knows)
      (f64.const 3.14159)
      (i32.const 20)
      (f64.abs (f64.const 2.71828)) ;; not a constant
      (i32.const 30)
      (rtt.canon $struct)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result f64)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 1
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (f64.const 3.14159)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 2
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 3
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 4
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 4
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
    (drop
      (struct.get $struct 1
        (call $create)
      )
    )
    (drop
      (struct.get $struct 2
        (call $create)
      )
    )
    (drop
      (struct.get $struct 3
        (call $create)
      )
    )
    (drop
      (struct.get $struct 4
        (call $create)
      )
    )
    ;; Also test for multiple gets of the same field.
    (drop
      (struct.get $struct 4
        (call $create)
      )
    )
  )
)

;; Never create A, but have a set to its field. A subtype B has no creates nor
;; sets, and the final subtype C has a create and a get. The set to A should
;; apply to it, preventing optimization.
(module
  ;; CHECK:      (type $A (struct_subtype (field (mut i32)) data))

  ;; CHECK:      (type $B (struct_subtype (field (mut i32)) $A))

  ;; CHECK:      (type $C (struct_subtype (field (mut i32)) $B))
  (type $C (struct_subtype (mut i32) $B))

  (type $A (struct (mut i32)))

  (type $B (struct_subtype (mut i32) $A))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_ref|$C| (func_subtype (result (ref $C)) func))

  ;; CHECK:      (func $create (type $none_=>_ref|$C|) (result (ref $C))
  ;; CHECK-NEXT:  (struct.new_with_rtt $C
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:   (rtt.canon $C)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $C))
    (struct.new_with_rtt $C
      (i32.const 10)
      (rtt.canon $C)
    )
  )
  ;; CHECK:      (func $set (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $A 0
  ;; CHECK-NEXT:   (ref.cast_static $A
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $set
    (struct.set $A 0
      (ref.cast_static $A
        (call $create)
      )
      (i32.const 20)
    )
  )
  ;; CHECK:      (func $get (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $C 0
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get
    (drop
      (struct.get $C 0
        (call $create)
      )
    )
  )
)

;; Copies of a field to itself can be ignored. As a result, we can optimize both
;; of the gets here.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_default_with_rtt $struct
  ;; CHECK-NEXT:   (rtt.canon $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new_default_with_rtt $struct
      (rtt.canon $struct)
    )
  )

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; This copy does not actually introduce any new possible values, and so it
    ;; remains true that the only possible value is the default.
    (struct.set $struct 0
      (call $create)
      (struct.get $struct 0
        (call $create)
      )
    )
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

;; Test of a near-copy, of a similar looking field (same index, and same field
;; type) but in a different struct. The value in both structs is the same, so
;; we can optimize.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut f32)) (field (mut i32)) data))
  (type $struct (struct (mut f32) (mut i32)))
  ;; CHECK:      (type $other (struct_subtype (field (mut f64)) (field (mut i32)) data))
  (type $other (struct (mut f64) (mut i32)))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_ref|$other| (func_subtype (result (ref $other)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create-struct (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (f32.const 0)
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-struct (result (ref $struct))
    (struct.new $struct
      (f32.const 0)
      (i32.const 42)
    )
  )

  ;; CHECK:      (func $create-other (type $none_=>_ref|$other|) (result (ref $other))
  ;; CHECK-NEXT:  (struct.new $other
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-other (result (ref $other))
    (struct.new $other
      (f64.const 0)
      (i32.const 42)
    )
  )

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 1
  ;; CHECK-NEXT:   (call $create-struct)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $other 1
  ;; CHECK-NEXT:      (call $create-other)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 1
  ;; CHECK-NEXT:      (call $create-struct)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As this is not a copy, we cannot optimize struct.1's get lower down.
    (struct.set $struct 1
      (call $create-struct)
      (struct.get $other 1
        (call $create-other)
      )
    )
    (drop
      (struct.get $struct 1
        (call $create-struct)
      )
    )
  )
)

;; As above, but each struct has a different value, so copying between them
;; inhibits one optimization.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut f32)) (field (mut i32)) data))
  (type $struct (struct (mut f32) (mut i32)))
  ;; CHECK:      (type $other (struct_subtype (field (mut f64)) (field (mut i32)) data))
  (type $other (struct (mut f64) (mut i32)))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_ref|$other| (func_subtype (result (ref $other)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create-struct (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (f32.const 0)
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-struct (result (ref $struct))
    (struct.new $struct
      (f32.const 0)
      (i32.const 42)
    )
  )

  ;; CHECK:      (func $create-other (type $none_=>_ref|$other|) (result (ref $other))
  ;; CHECK-NEXT:  (struct.new $other
  ;; CHECK-NEXT:   (f64.const 0)
  ;; CHECK-NEXT:   (i32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-other (result (ref $other))
    (struct.new $other
      (f64.const 0)
      (i32.const 1337)
    )
  )

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 1
  ;; CHECK-NEXT:   (call $create-struct)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $other 1
  ;; CHECK-NEXT:      (call $create-other)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1337)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 1
  ;; CHECK-NEXT:    (call $create-struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As this is not a copy, we cannot optimize struct.1's get lower down.
    (struct.set $struct 1
      (call $create-struct)
      (struct.get $other 1
        (call $create-other)
      )
    )
    (drop
      (struct.get $struct 1
        (call $create-struct)
      )
    )
  )
)

;; Test of a near-copy, of a different index.
(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) (field (mut i32)) data))
  (type $struct (struct (mut i32) (mut i32)))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $create (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:   (i32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create (result (ref $struct))
    (struct.new $struct
      (i32.const 42)
      (i32.const 1337)
    )
  )

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (call $create)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 1
  ;; CHECK-NEXT:      (call $create)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1337)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (call $create)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As this is not a copy, we cannot optimize struct.0's get lower down.
    (struct.set $struct 0
      (call $create)
      (struct.get $struct 1
        (call $create)
      )
    )
    (drop
      (struct.get $struct 0
        (call $create)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct_subtype  data))
  (type $A (struct))
  (type $B (struct (ref $A)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global (ref $A) (struct.new_default $A))
  (global $global (ref $A) (struct.new $A))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (global.get $global)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; An immutable global is the only thing written to this field, so we can
    ;; propagate the value to the struct.get and replace it with a global.get.
    (drop
      (struct.get $B 0
        (struct.new $B
          (global.get $global)
        )
      )
    )
  )
)

;; As above, but with an imported global
(module
  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (global $global i32))
  (import "a" "b" (global $global i32))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (global.get $global)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global i32 (i32.const 42))
  (global $global i32 (i32.const 42))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; An immutable global is the only thing written to this field, so we can
    ;; propagate the value to the struct.get to get 42 here (even better than a
    ;; global.get as in the last examples).
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global (mut i32) (i32.const 42))
  (global $global (mut i32) (i32.const 42))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but the global is *not* immutable. Still, it has no writes, so
    ;; we can optimize.
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct i32))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global (mut i32) (i32.const 42))
  (global $global (mut i32) (i32.const 42))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (global.set $global
  ;; CHECK-NEXT:   (i32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (global.get $global)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but the global does have another write of another value, which
    ;; prevents optimization.
    (global.set $global
      (i32.const 1337)
    )
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global i32 (i32.const 42))
  (global $global i32 (i32.const 42))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but there is another set of the field that is the same,
    ;; so that is fine. Also, the struct's field is now mutable as well to allow
    ;; that, and that also does not prevent optimization.
    (struct.set $struct 0
      (struct.new $struct
        (global.get $global)
      )
      (i32.const 42)
    )
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global i32 (i32.const 42))
  (global $global i32 (i32.const 42))
  ;; CHECK:      (global $global-2 i32 (i32.const 1337))
  (global $global-2 i32 (i32.const 1337))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 42)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but set a different global, which prevents optimization.
    (struct.set $struct 0
      (struct.new $struct
        (global.get $global)
      )
      (global.get $global-2)
    )
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field (mut i32)) data))
  (type $struct (struct (mut i32)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global i32 (i32.const 42))
  (global $global i32 (i32.const 42))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 1337)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $struct 0
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 42)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but set a constant, which means we are mixing constants with
    ;; globals, which prevents the optimization of the struct.get.
    (struct.set $struct 0
      (struct.new $struct
        (global.get $global)
      )
      (i32.const 1337)
    )
    (drop
      (struct.get $struct 0
        (struct.new $struct
          (global.get $global)
        )
      )
    )
  )
)

(module
  ;; Test a global type other than i32. Arrays of structs are a realistic case
  ;; as they are used to implement itables.

  ;; CHECK:      (type $vtable (struct_subtype (field funcref) data))
  (type $vtable (struct funcref))

  ;; CHECK:      (type $itable (array_subtype (ref $vtable) data))
  (type $itable (array (ref $vtable)))

  (type $object (struct (field $itable (ref $itable))))

  ;; CHECK:      (type $none_=>_funcref (func_subtype (result funcref) func))

  ;; CHECK:      (global $global (ref $itable) (array.init_static $itable
  ;; CHECK-NEXT:  (struct.new $vtable
  ;; CHECK-NEXT:   (ref.null func)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.new $vtable
  ;; CHECK-NEXT:   (ref.func $test)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: ))
  (global $global (ref $itable) (array.init_static $itable
    (struct.new $vtable
      (ref.null func)
    )
    (struct.new $vtable
      (ref.func $test)
    )
  ))

  ;; CHECK:      (func $test (type $none_=>_funcref) (result funcref)
  ;; CHECK-NEXT:  (struct.get $vtable 0
  ;; CHECK-NEXT:   (array.get $itable
  ;; CHECK-NEXT:    (global.get $global)
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test (result funcref)
    ;; Realistic usage of an itable: read an item from it, then a func from
    ;; that, and return the value (all verifying that the types are correct
    ;; after optimization). Note how after optimization everything is lined up
    ;; so that precompute-propagate can infer from the global.get the specific
    ;; object the array.get is on, allowing us to emit a constant value for the
    ;; outer struct.get in principle.
    (struct.get $vtable 0
      (array.get $itable
        (struct.get $object $itable
          (struct.new $object
            (global.get $global)
          )
        )
        (i32.const 1)
      )
    )
  )
)
