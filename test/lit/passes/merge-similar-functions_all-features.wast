;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --all-features --merge-similar-functions -S -o - | filecheck %s

(module
  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $[i8] (array i8))
  (type $[i8] (array i8))

  ;; CHECK:      (type $arrayref_=>_none (func (param arrayref)))

  ;; CHECK:      (type $ref|eq|_=>_none (func (param (ref eq))))

  ;; CHECK:      (func $take-ref-null-array (type $arrayref_=>_none) (param $0 arrayref)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $take-ref-null-array (param (ref null array))
    (unreachable)
  )
  ;; CHECK:      (func $take-ref-eq (type $ref|eq|_=>_none) (param $0 (ref eq))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $take-ref-eq (param (ref eq))
    (unreachable)
  )

  ;; NOTE: When type A is a subtype of type B and type C,
  ;; and func X takes a type B arg, and func Y takes a type C arg.
  ;; Then both func X and Y are callable with a type A arg.
  ;; But in general, type B and C don't have a common subtype, so
  ;; we can't merge call instructions of func X and Y.

  ;; CHECK:      (func $no-call-subtyping-same-operand-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (call $take-ref-null-array
  ;; CHECK-NEXT:   (array.new_fixed $[i8] 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $no-call-subtyping-same-operand-0
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (call $take-ref-null-array
      (array.new_fixed $[i8] 0)
    )
  )
  ;; CHECK:      (func $no-call-subtyping-same-operand-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (call $take-ref-eq
  ;; CHECK-NEXT:   (array.new_fixed $[i8] 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $no-call-subtyping-same-operand-1
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (call $take-ref-eq
      (array.new_fixed $[i8] 0)
    )
  )
)

;; Test that we can merge properly when there is a return_call.
(module
  ;; CHECK:      (type $none_=>_i32 (func (result i32)))

  ;; CHECK:      (type $ref|none_->_i32|_=>_i32 (func (param (ref $none_=>_i32)) (result i32)))

  ;; CHECK:      (elem declare func $return_a $return_b)

  ;; CHECK:      (func $return_call_a (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (call $byn$mgfn-shared$return_call_a
  ;; CHECK-NEXT:   (ref.func $return_a)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $return_call_a (result i32)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (return_call $return_a)
  )

  ;; CHECK:      (func $return_call_b (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (call $byn$mgfn-shared$return_call_a
  ;; CHECK-NEXT:   (ref.func $return_b)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $return_call_b (result i32)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    (nop) (nop) (nop) (nop) (nop) (nop)
    ;; As above, but now use a return_call.
    (return_call $return_b)
  )

  ;; CHECK:      (func $return_a (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 0)
  ;; CHECK-NEXT: )
  (func $return_a (result i32)
    ;; Helper function.
    (i32.const 0)
  )

  ;; CHECK:      (func $return_b (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 1)
  ;; CHECK-NEXT: )
  (func $return_b (result i32)
    ;; Helper function.
    (i32.const 1)
  )
)
;; CHECK:      (func $byn$mgfn-shared$return_call_a (type $ref|none_->_i32|_=>_i32) (param $0 (ref $none_=>_i32)) (result i32)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (nop)
;; CHECK-NEXT:  (return_call_ref $none_=>_i32
;; CHECK-NEXT:   (local.get $0)
;; CHECK-NEXT:  )
;; CHECK-NEXT: )
